var documenterSearchIndex = {"docs":
[{"location":"lorentz.html#PiecewiseLorentz","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"","category":"section"},{"location":"lorentz.html#Installation","page":"PiecewiseLorentz","title":"Installation","text":"","category":"section"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The package won't work without Piecewise. Both can be installed with Pkg.add.","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"using Pkg; Pkg.add(\"Piecewise\"); Pkg.add(\"PiecewiseLorentz\")","category":"page"},{"location":"lorentz.html#Introduction","page":"PiecewiseLorentz","title":"Introduction","text":"","category":"section"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The order-m Lorentz transform of a function f(x) of a real variable x is defined as","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"left(L^mcirc fright)(y z) = int_-infty^inftydxf(x)\nleftfrac-mathrmImzpi(y-mathrmRez-x)^2+(mathrmImz)^2right^m","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"where m is a positive integer, y is a real number, and z is a complex number with strictly negative imaginary part. The name Lorentz transform was chosen, because the function in square brackets is a Lorentzian of half-width mathrmImz centered at x=y-mathrmRez.","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The module PiecewiseLorentz adds to the Formulas defined in the module Piecewise the primitive functions corresponding to the order-m Lorentz kernel leftfrac-mathrmImzpi(y-mathrmRez-x)^2+(mathrmImz)^2right^m, enabling the fast Lorentz transform of PiecewiseFunction objects using these formulas.","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"warning: Warning\nThe present version only implements m=123 for the formulas POLY, LOG, PLS, and XLOG. Note that the m=1 Lorentz transform is equivalent to a Hilbert transform:left(L^1circ fright)(y z) = -frac1pimathrmIm\nleft(Hcirc fright)(y-z)","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The method lorentz_transform return the Lorentz transform of a PiecewiseFunction object, as calculated using the definition above. The transform has algebraic tails at large y, that may suffer from numerical errors. A numerically more stable moment expansion is therefore used for large values of y-mathrmRez. Both the definition and the moment expansion are implemented in a LorentzTransform object created as:","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"L = LorentzTransform(f::PiecewiseFunction, m::Integer[, ground::Real])","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The moment expansion is used if y-mathrmRez is outside the support of the piecewise function f and if the definition yields a result smaller than ground (by default 1e-10). Once initialized, the Lorentz transform can be evaluated as L(y, z).","category":"page"},{"location":"lorentz.html#momentexpansion-L","page":"PiecewiseLorentz","title":"Moment expansion","text":"","category":"section"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The expansion of the order-m Lorentz transform for large y-mathrmRez is","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"beginalign*\nleft(L^mcirc fright)(y z)=sum_n=2m^infty\nfrac1(y-mathrmRez)^n\nint_-infty^inftydxf(x)P_n^(m)(xmathrmImz)\nP_n^(m)(xa)=frac1nfracd^ndu^n\nleftfrac-api(1u-x)^2+a^2right^m_u=0\n=left(fraca2piright)^mfrac2(m-1)\nsum_k=0^n-2mcosleft((n-k)fracpi2right)\nquadtimesfrac(n-1)k(n-k-2m)(n-k-1)a^n-k-2mx^k\nendalign*","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"Dropping the terms that vanish because of the cosine, this can be recast as","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"beginalign*\nleft(L^mcirc fright)(y z)=left(frac-mathrmImz2piright)^m\nfrac2(m-1)frac1(y-mathrmRez)^2m\nsum_n=0^inftyfrac1(y-mathrmRez)^n\nsum_k=0^ndoteqdot 2C_nk^(m)(mathrmImz)^2k\nC_nk^(m)=(-1)^kfrac(2m+n-1)(n-2k)(2k)(2m+2k-1)(Mcirc f)(n-2k)\nendalign*","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"where ndoteqdot 2 means the integer division of n by 2. The structure LorentzTransform stores the piecewise function and the expansion coefficients C_nk^(m). If y-mathrmRez is outside the support of the function f(x) and if the definition of the Lorentz transform yields a result smaller than ground, the moment expansion is used.","category":"page"},{"location":"lorentz.html#Primitives","page":"PiecewiseLorentz","title":"Primitives","text":"","category":"section"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"Here, we describe the primitives added by PiecewiseLorentz to the Formulas provided by Piecewise. In order to handle even and odd piecewise functions, we define the primitive of F(xmathbfa)leftfrac-mathrmImzpi(y-mathrmRez-sx)^2+(mathrmImz)^2right^m as mathcalF_m(sxmathbfayz) with s=pm1. ","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"POLY |  LOG |  PLS XLOG","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"","category":"page"},{"location":"lorentz.html#POLY-L","page":"PiecewiseLorentz","title":"POLY","text":"","category":"section"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The function POLY.value(x, a) is","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"F(xmathbfa) = sum_i=1^k a_i x^i-1","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The primitive function for the Lorentz kernel of order m is","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"beginequation*\nmathcalF_m(sxmathbfayz) = leftfrac-mathrmImzpi(y-mathrmRez)^2+(mathrmImz)^2\nright^msum_i=1^kfraca_ix^ii\nF_1left(immi+1fracsxy-zfracsxy-z^*right)\nendequation*","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"where F_1 is the Appell function.","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"Since the Appell function isn't available yet in pure Julia [1], we use alternate forms for m=1, 2, and 3, that involve the hypergeometric function _2F_1(abcz):","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"beginalign*\nmathcalF_1(sxmathbfayz) =\nfrac-mathrmImzpi(y-mathrmRez)^2+(mathrmImz)^2\nsum_i=1^kfraca_ix^iimathrmReleftfracy-z^*z-z^*\nleft2_2F_1left(1ii+1fracsxy-zright)rightright\nmathcalF_2(sxmathbfayz) =\nfrac12pi^2(y-mathrmRez)^2+(mathrmImz)^2\nsum_i=1^kfraca_ix^iimathrmReleftfracy-z^*z-z^*\nleftphantomfrac11rightright\nquadleftleftleft(2+(i-1)fracz-z^*y-zright)\n_2F_1left(1ii+1fracsxy-zright)\n-ifracz-z^*y-z-sxrightright\nmathcalF_3(sxmathbfayz) =\n-frac116pi^3mathrmImz(y-mathrmRez)^2+(mathrmImz)^2\nsum_i=1^kfraca_ix^iimathrmReleftfracy-z^*y-z\nleftphantomfrac11rightright\nquadleft(12+6(i-1)fracz-z^*y-z\n+(i-1)(i-2)left(fracz-z^*y-zright)^2right)\n_2F_1left(1ii+1fracsxy-zright)\nquadleftleft-6ifracz-z^*y-z-sx+ileft(1-(i-2)\nfracy-z-sxy-zright)left(fracz-z^*y-z-sxright)^2rightright\nendalign*","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"_2F_1(abcz) is continuous for zinmathbbC, except on the real axis z=rinmathbbR for r1. Since sx(y-z) crosses the real axis at x=0, the primitives are continuous for xinmathbbR.","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"[1]: It would be available through sympy.functions.special.hyper.appellf1.","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"","category":"page"},{"location":"lorentz.html#LOG-L","page":"PiecewiseLorentz","title":"LOG","text":"","category":"section"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The function LOG.value(x, a) is","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"F(xmathbfa) = a_2lnx-a_1","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The primitive function is unknown for the Lorentz kernel of general order. For the orders m=1, 2, and 3, they are","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"beginalign*\nmathcalF_1(sxmathbfayz) = fracsa_2pimathrmImleft\nlnx-a_1lnleft(fracy-z-sxy-z-sa_1right)\n+mathrmLi_2left(fracs(x-a_1)y-z-sa_1right)right\nmathcalF_2(sxmathbfayz) = -fracsa_22pi^2mathrmImz\nmathrmImleftlnx-a_1lnleft(fracy-z-sxy-z-sa_1right)\n+mathrmLi_2left(fracs(x-a_1)y-z-sa_1right)right\nquadleft+imathrmImzleftfraclnx-a_1y-z-sx\n+fracln(y-z-sx)-lnx-a_1y-z-sa_1rightright\nmathcalF_3(sxmathbfayz) = frac3sa_28pi^3(mathrmImz)^2\nmathrmImleftlnx-a_1lnleft(fracy-z-sxy-z-sa_1right)\n+mathrmLi_2left(fracs(x-a_1)y-z-sa_1right)right\nquad+imathrmImzleftfraclnx-a_1y-z-sx\n+fracln(y-z-sx)-lnx-a_1y-z-sa_1right\n+frac(mathrmImz)^23leftfraclnx-a_1(y-z-sx)^2right\nquadleftleft+fracln(y-z-sx)-lnx-a_1(y-z-sa_1)^2\n-frac1(y-z-sa_1)(y-z-sx)rightright\nendalign*","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"where mathrmLi_2(z) is the polylogarithm. Both functions ln(z) and mathrmLi_2(z) are continuous for zinmathbbC, except on the real axis, where the imaginary part has a branch cut. Since both (y-z-sx)(y-z-sa_1) and s(x-a_1)(y-z-a_1) cross the real axis at x=a_1, the primitives are continuous in the domains where they can be used.","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"","category":"page"},{"location":"lorentz.html#PLS-L","page":"PiecewiseLorentz","title":"PLS","text":"","category":"section"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The function PLS.value(x, a) is","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"F(xmathbfa) = a_3x-a_1^a_2","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The primitive function for the Lorentz kernel of order m is","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"beginalign*\nmathcalF_m(sxmathbfayz) = leftfrac-mathrmImzpi(y-mathrmRez-sa_1)^2+(mathrmImz)^2\nright^ma_3x-a_1^a_2fracx-a_1a_2+1\nquadtimes F_1left(a_2+1mma_2+2fracs(x-a_1)y-z-sa_1\nfracs(x-a_1)y-z^*-sa_1right)\nendalign*","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"where F_1 is the Appell function.","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"Since the Appell function isn't available yet in pure Julia [1], we use alternate forms for m=1, 2, and 3, that involve the hypergeometric function _2F_1(abcz):","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"beginalign*\nmathcalF_1(sxmathbfayz) = \nfrac-mathrmImzpi(y-mathrmRez-sa_1)^2+(mathrmImz)^2\na_3x-a_1^a_2fracx-a_1a_2+1\nmathrmReleftphantomfrac11right\nquadleftfracy-z^*-sa_1z-z^*left\n2_2F_1left(1a_2+1a_2+2fracs(x-a_1)y-z-sa_1right)rightright\nmathcalF_2(sxmathbfayz) =\nfrac12pi^2(y-mathrmRez-sa_1)^2+(mathrmImz)^2\na_3x-a_1^a_2fracx-a_1a_2+1\nmathrmReleftphantomfrac11right\nquadfracy-z^*-sa_1z-z^*leftleft(2+a_2fracz-z^*y-z-sa_1right)\n_2F_1left(1a_2+1a_2+2fracs(x-a_1)y-z-sa_1right)right\nquadleftleft-(a_2+1)fracz-z^*y-z-sxrightright\nmathcalF_3(sxmathbfayz) =\n-frac116pi^3mathrmImz(y-mathrmRez-sa_1)^2+(mathrmImz)^2\na_3x-a_1^a_2fracx-a_1a_2+1\nmathrmReleftphantomfrac11right\nquadfracy-z^*-sa_1z-z^*leftleft(12+6a_2fracz-z^*y-z-sa_1\n+a_2(a_2-1)left(fracz-z^*y-z-sa_1right)^2right)right\nquadtimes_2F_1left(1a_2+1a_2+2fracs(x-a_1)y-z-sa_1right)\n-6(a_2+1)fracz-z^*y-z-sx\nquadleftleft+(a_2+1)left(1-(a_2-1)\nfracy-z-sxy-z-sa_1right)\nleft(fracz-z^*y-z-sxright)^2rightright\nendalign*","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"_2F_1(abcz) is continuous for zinmathbbC, except on the real axis, where the imaginary part has a branch cut. Since s(x-a_1)(y-z-sa_1) crosses the real axis at x=a_1, the primitives are continuous in the domain, which must exclude a_1.","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"","category":"page"},{"location":"lorentz.html#XLOG-L","page":"PiecewiseLorentz","title":"XLOG","text":"","category":"section"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The function XLOG.value(x, a) is","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"F(xmathbfa) = a_2xlnx-a_1","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"The primitive function is unknown for the Lorentz kernel of general order. For the orders m=1, 2, and 3, they are","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"beginalign*\nmathcalF_1(sxmathbfayz) = fraca_2pimathrmImleft\n(y-z)leftlnx-a_1lnleft(fracy-z-sxy-z-sa_1right)\n+mathrmLi_2left(fracs(x-a_1)y-z-sa_1right)rightright\nmathcalF_2(sxmathbfayz) = -fraca_22pi^2mathrmImz\nmathrmImleft(y-mathrmRez)left\nlnx-a_1lnleft(fracy-z-sxy-z-sa_1right)\n+mathrmLi_2left(fracs(x-a_1)y-z-sa_1right)rightright\nquadleft+i(y-z)mathrmImzleftfraclnx-a_1y-z-sx\n+fracln(y-z-sx)-lnx-a_1y-z-sa_1rightright\nmathcalF_3(sxmathbfayz) = frac3a_28pi^3(mathrmImz)^2\nmathrmImleft(y-mathrmRez)left\nlnx-a_1lnleft(fracy-z-sxy-z-sa_1right)\n+mathrmLi_2left(fracs(x-a_1)y-z-sa_1right)rightright\nquad+ileft(y-z+frac2i3mathrmImzright)\nmathrmImzleftfraclnx-a_1y-z-sx\n+fracln(y-z-sx)-lnx-a_1y-z-sa_1right\nquad+frac(mathrmImz)^23(y-z)leftfraclnx-a_1(y-z-sx)^2\n+fracln(y-z-sx)-lnx-a_1(y-z-sa_1)^2right\nquadleftleft-frac1(y-z-sa_1)(y-z-sx)rightright\nendalign*","category":"page"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"where mathrmLi_2(z) is the polylogarithm. Both functions ln(z) and mathrmLi_2(z) are continuous for zinmathbbC, except on the real axis, where the imaginary part has a branch cut. Since both (y-z-sx)(y-z-sa_1) and s(x-a_1)(y-z-a_1) cross the real axis at x=a_1, the primitives are continuous in the domains where they can be used.","category":"page"},{"location":"lorentz.html#Public-interface","page":"PiecewiseLorentz","title":"Public interface","text":"","category":"section"},{"location":"lorentz.html#Index","page":"PiecewiseLorentz","title":"Index","text":"","category":"section"},{"location":"lorentz.html","page":"PiecewiseLorentz","title":"PiecewiseLorentz","text":"Pages   = [\"lorentz.md\"]\nModules = [PiecewiseLorentz]\nOrder   = [:type, :function]","category":"page"},{"location":"lorentz.html#Type","page":"PiecewiseLorentz","title":"Type","text":"","category":"section"},{"location":"lorentz.html#PiecewiseLorentz.LorentzTransform","page":"PiecewiseLorentz","title":"PiecewiseLorentz.LorentzTransform","text":"LorentzTransform(f::PiecewiseFunction, m::Integer[, ground::Real=1e-10])\n\nReturn a LorentzTransform object for the piecewise function f.\n\nm is the order of the transform. The LorentzTransform object behaves as a function with arguments (y::Real, z::Complex). A moment expansion is used if y-mathrmRez is outside the support of the piecewise function and if the result of the transform is smaller than ground.\n\nFields\n\nf::PiecewiseFunction\nm::Integer\nground::Real\nmoments::Vector{Real}\n\nExample\n\nL^2 transform of a box:\n\njulia> L = LorentzTransform(PiecewiseFunction(Piece((-1, 1), POLY, [1])), 2)\n< L^2 transform of piecewise function with support [-1.0, 1.0] >\n\njulia> L(0, -im)\n0.13023806336711655\n\n\n\n\n\n","category":"type"},{"location":"lorentz.html#Methods","page":"PiecewiseLorentz","title":"Methods","text":"","category":"section"},{"location":"lorentz.html#PiecewiseLorentz.lorentz_transform","page":"PiecewiseLorentz","title":"PiecewiseLorentz.lorentz_transform","text":"lorentz_transform(f::PiecewiseFunction, m::Integer, y::Real, z::Complex)\n\nReturn the Lorentz transform of the piecewise function f:\n\n(L^mcirc f)(y z) = int_-infty^inftydxf(x)leftfracmathrmIm\nzpi(y-mathrmRez-x)^2+(mathrmImz)^2right^m\n\nExample\n\njulia> lorentz_transform(PiecewiseFunction([Piece((-1, 1), POLY, [1])]), 2, 0, -im)\n0.13023806336711655\n\nSee also LorentzTransform.\n\n\n\n\n\n","category":"function"},{"location":"hilbert.html#PiecewiseHilbert","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"","category":"section"},{"location":"hilbert.html#Installation","page":"PiecewiseHilbert","title":"Installation","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The package won't work without Piecewise. Both can be installed with Pkg.add.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"using Pkg; Pkg.add(\"Piecewise\"); Pkg.add(\"PiecewiseHilbert\")","category":"page"},{"location":"hilbert.html#Introduction","page":"PiecewiseHilbert","title":"Introduction","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The Hilbert transform of a function f(x) of a real variable x is defined as","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"(Hcirc f)(z) = int_-infty^inftydxfracf(x)z-x","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"where zinmathbbCsetminusmathbbR is a complex number with non-zero imaginary part. The transform is well-defined if f(x) has no non-integrable singularity and if it vanishes at infinity faster than x^-epsilon with epsilon0 [1]. In the limiting case epsilon=0, the transform is well-defined only if f(+infty)=f(-infty).","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"[1]: We have int^x x^-epsilon(z-x)=(mathrmsign(x)z)^epsilonB_xz(1-epsilon0), where B_z(a b) is the incomplete beta function, which approaches -pi (mp1z)^epsilonsin(piepsilon) for xtopminfty.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The module PiecewiseHilbert adds to the Formulas defined in the module Piecewise the primitive functions corresponding to the Hilbert kernel 1(z-x), enabling the fast Hilbert transform of piecewise functions using these formulas.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The method hilbert_transform returns the Hilbert transform of a PiecewiseFunction object, as calculated using the definition above. It also works with user-defined Formula objects. Depending on the formulas used, however, the result can be numerically unstable at large z. This is circumvented by means of a moment expansion. Both the definition and the moment expansion are implemented in a HilbertTransform object created as:","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"H = HilbertTransform(f::PiecewiseFunction[, radius::Real])","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The moment expansion is used if z radius (set automatically by default). Once initialized, the Hilbert transform can be evaluated as H(z).","category":"page"},{"location":"hilbert.html#momentexpansion-H","page":"PiecewiseHilbert","title":"Moment expansion","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The large-z expansion of the Hilbert transform is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"(Hcirc f)(z) = sum_n=0^inftyfrac(Mcirc f)(n)z^n+1qquad\n(Mcirc f)(n) = int_-infty^inftydxf(x)x^n","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The structure HilbertTransform stores the piecewise function and its moments, as provided by the method moment of Piecewise, such that a numerically stable result is produced using the definition of the Hilbert transform within a given disk in the complex plane and the moment expansion beyond that disk.","category":"page"},{"location":"hilbert.html#Primitives","page":"PiecewiseHilbert","title":"Primitives","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"Here, we describe the primitives added by PiecewiseHilbert to the Formulas provided by Piecewise.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"POLY |  TAIL |  LOG | ISRS | PLS | XLOG | XISRS","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"","category":"page"},{"location":"hilbert.html#POLY-H","page":"PiecewiseHilbert","title":"POLY","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The function POLY.value(x, a) is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"F(xmathbfa) = sum_i=1^k a_i x^i-1","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"A primitive function for the Hilbert kernel is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"mathcalF(xmathbfaz) = -ln(x-z)sum_i=1^k a_i z^i-1\n-sum_i=0^k-2z^isum_j=i^k-2a_j+2fracx^j-i+1j-i+1","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"This primitive is interesting, because it involves only elementary functions. Unfortunately, it suffers from numerical instability at large z. We use another primitive that is stable at large z, although slightly slower as it requires the hypergeometric function _2F_1(abcz):","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"mathcalF(xmathbfaz) = frac1zsum_i=1^kfraca_ix^ii\n_2F_1left(1ii+1fracxzright)","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"This primitive is continuous for xinmathbbR.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"","category":"page"},{"location":"hilbert.html#TAIL-H","page":"PiecewiseHilbert","title":"TAIL","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The function TAIL.value(x, a) is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"F(xmathbfa) = fraca_1+a_2xa_3+a_4x+a_5x^2","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The primitive function for the Hilbert kernel is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"beginalign*\nmathcalF(xmathbfaz) = -frac1a_3+a_4z+a_5z^2left\n(a_1+a_2z)leftln(z-x)-lnsqrta_3+a_4x+a_5x^2right\nphantomfracfrac1_1^11_1^11_1^1right\nquadleft -left2a_2a_3-a_1a_4+(a_2a_4-2a_1a_5)zright\nfractanh^-1left(fraca_4+2a_5xDeltaright)Deltaright\nendalign*","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"where Delta=sqrta_4^2-4a_3a_5. This primitive is obviously continuous for xinmathbbR if a_4^2-4a_3a_50, because in that case the zeros x_pm of a_3+a_4x+a_5x^2 are not on the real axis, such that a_3+a_4x+a_5x^2 does not change sign and, therefore, has the sign of a_3. If a_4^2-4a_3a_50, both lnsqrtcdots and tanh^-1(cdots) have a discontinuous imaginary part at x=x_pm. However, since none of these zeros lies inside the domain, the function is continuous in the domain.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"","category":"page"},{"location":"hilbert.html#LOG-H","page":"PiecewiseHilbert","title":"LOG","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The function LOG.value(x, a) is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"F(xmathbfa) = a_2lnx-a_1","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The primitive function for the Hilbert kernel is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"mathcalF(xmathbfaz) = -a_2leftlnx-a_1\nlnleft(fracz-xz-a_1right)\n+mathrmLi_2left(fracx-a_1z-a_1right)right","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"where mathrmLi_2(z) is the polylogarithm. Both functions ln(z) and mathrmLi_2(z) are continuous for zinmathbbC, except on the real axis, where the imaginary part has a branch cut. Since both (z-x)(z-a_1) and (x-a_1)(z-a_1) cross the real axis at x=a_1, the primitive is continuous in the domains where it can be used.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"","category":"page"},{"location":"hilbert.html#ISRS-H","page":"PiecewiseHilbert","title":"ISRS","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The function ISRS.value(x, a) is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"F(xmathbfa) = fraca_2sqrtx^2-a_1^2","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The primitive function for the Hilbert kernel is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"mathcalF(xmathbfaz) = -fraca_2sqrtx^2-a_1^2\nfracsqrtx^2-a_1^2sqrtz^2-a_1^2tanh^-1\nleft(fraca_1^2-xzsqrtx^2-a_1^2sqrtz^2-a_1^2right)","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"This primitive is discontinuous at x=pm a_1 but continuous everywhere else, so it is continuous inside the domains where it can be used.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"","category":"page"},{"location":"hilbert.html#PLS-H","page":"PiecewiseHilbert","title":"PLS","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The function PLS.value(x, a) is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"F(xmathbfa) = a_3x-a_1^a_2","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The primitive function for the Hilbert kernel is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"mathcalF(xmathbfaz) = fraca_3x-a_1^a_21+a_2\nfracx-a_1z-a_1_2F_1left(1a_2+1a_2+2fracx-a_1z-a_1right)","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"where _2F_1(abcz) is the hypergeometric function. _2F_1(abcz) is continuous for zinmathbbC, except on the real axis, where the imaginary part has a branch cut. Since (x-a_1)(z-a_1) crosses the real axis at x=a_1, the primitive is continuous in the domain, which must exclude a_1.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"","category":"page"},{"location":"hilbert.html#XLOG-H","page":"PiecewiseHilbert","title":"XLOG","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The function XLOG.value(x, a) is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"F(xmathbfa) = a_2xlnx-a_1","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The primitive function for the Hilbert kernel is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"mathcalF(xmathbfaz) = a_2leftx-lnx-a_1leftx-a_1\n+zlnleft(fracz-xz-a_1right)right\n-zmathrmLi_2left(fracx-a_1z-a_1right)right","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"where mathrmLi_2(z) is the polylogarithm. Both functions ln(z) and mathrmLi_2(z) are continuous for zinmathbbC, except on the real axis, where the imaginary part has a branch cut. Since both (z-x)(z-a_1) and (x-a_1)(z-a_1) cross the real axis at x=a_1, the primitive is continuous in the domains where it can be used.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"","category":"page"},{"location":"hilbert.html#XISRS-H","page":"PiecewiseHilbert","title":"XISRS","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The function XISRS.value(x, a) is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"F(xmathbfa) = fraca_2xsqrtx^2-a_1^2","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The primitive function for the Hilbert kernel is","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"mathcalF(xmathbfaz) = -fraca_2sqrtx^2-a_1^2sqrtx^2-a_1^2\nlefttanh^-1left(fracxsqrtx^2-a_1^2right)\n+fraczsqrtz^2-a_1^2tanh^-1left(fraca_1^2-xz\nsqrtx^2-a_1^2sqrtz^2-a_1^2right)right","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"This primitive is discontinuous at x=pm a_1 but continuous everywhere else, so it is continuous inside the domains where it can be used.","category":"page"},{"location":"hilbert.html#Example","page":"PiecewiseHilbert","title":"Example","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"The following example produces an image similar to the Piecewise logo.","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing ..Piecewise, ..PiecewiseHilbert # hide\nf = PiecewiseFunction([\n    Piece((-1, -6/10), (true, false), LOG, [-6/10, -1]),\n    Piece((-6/10, -3/10), (false, true), [POLY, LOG], [[2, 10/3], [-6/10, -1]]),\n    Piece((-3/10, 0), (false, true), [POLY, LOG, XLOG],\n        [[1+log(10/3)], [-3/10, 1+1/log(10/3)], [-3/10, 10/3*(1+1/log(10/3))]]),\n    Piece((2/10, 5/10), (false, false), [XISRS, LOG], [[2/10, 1], [5/10, -1]]),\n    Piece((5/10, 1), (false, false), [POLY, LOG, PLS],\n        [[log(1/2)], [5/10, -1], [1, 1/4, 1]])\n])\n\nH = HilbertTransform(f)\n\nusing Plots\nz1 = -2:0.001:1.5\nplot(xlim=(-1.1, 1.1), ylim=(0, 6), axis=false, grid=false, legend=:none)\nfor z2 in reverse(0.01:0.015:0.6)\n    plot!(z1 .+ z2*4/3, -imag.(H.(z1 .+ im*z2^2))/π .+ z2*20/3,\n        color=:grey, fill=(0, :white))\nend\nplot!(z1, f.(z1), linewidth = 5, color = :red, fill=(0, :pink))\nsavefig(\"logo.svg\"); nothing # hide","category":"page"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"(Image: )","category":"page"},{"location":"hilbert.html#Public-interface","page":"PiecewiseHilbert","title":"Public interface","text":"","category":"section"},{"location":"hilbert.html#Index","page":"PiecewiseHilbert","title":"Index","text":"","category":"section"},{"location":"hilbert.html","page":"PiecewiseHilbert","title":"PiecewiseHilbert","text":"Pages   = [\"hilbert.md\"]\nModules = [PiecewiseHilbert]\nOrder   = [:type, :function]","category":"page"},{"location":"hilbert.html#Type","page":"PiecewiseHilbert","title":"Type","text":"","category":"section"},{"location":"hilbert.html#PiecewiseHilbert.HilbertTransform","page":"PiecewiseHilbert","title":"PiecewiseHilbert.HilbertTransform","text":"HilbertTransform(f::PiecewiseFunction[, radius::Real])\n\nReturn a HilbertTransform object for the piecewise function f.\n\nThe HilbertTransform object behaves as a function with argument (z::Complex). A moment expansion is used beyond z = radius in the complex plane. If not specified, the radius is set automatically. The field error gives an estimate of the absolute error at z = radius.\n\nFields\n\nf::PiecewiseFunction\nradius::Real\nmoments::Vector{Real}\nerror::Real\n\nExample\n\nHilbert transform of a box:\n\njulia> H = HilbertTransform(PiecewiseFunction(Piece((-1, 1), POLY, [1])))\n< Hilbert transform of piecewise function with support [-1.0, 1.0] >\n\njulia> H.([1im, 10im, 100im])\n3-element Vector{ComplexF64}:\n 0.0 - 1.5707963267948966im\n 0.0 - 0.19933730476190478im\n 0.0 - 0.019999333333333334im\n\n\n\n\n\n","category":"type"},{"location":"hilbert.html#Methods","page":"PiecewiseHilbert","title":"Methods","text":"","category":"section"},{"location":"hilbert.html#PiecewiseHilbert.hilbert_transform","page":"PiecewiseHilbert","title":"PiecewiseHilbert.hilbert_transform","text":"hilbert_transform(f::PiecewiseFunction, z::Complex)\n\nReturn the Hilbert transform of the piecewise function f at the complex number z:\n\n(Hcirc f)(z) = int_-infty^inftydxfracf(x)z-x\n\nExample\n\njulia> hilbert_transform(PiecewiseFunction([Piece((-1, 1), POLY, [1])]), im)\n0.0 - 1.5707963267948966im\n\nSee also HilbertTransform.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Piecewise","page":"Piecewise","title":"Piecewise","text":"","category":"section"},{"location":"index.html#Installation","page":"Piecewise","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The package can be installed with Pkg.add.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"using Pkg; Pkg.add(\"Piecewise\")","category":"page"},{"location":"index.html#Introduction","page":"Piecewise","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A piecewise function of a real variable x returns a value computed with a formula that depends on the interval in which x lies. The Julia module Piecewise represents such a function as a collection of pieces. Each piece is an object of type Piece that contains an interval and a rule to compute a value, given x. The rule is expressed by formulas, that are contained in objects of type Formula.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"In mathematical terms, a piecewise function can be written as","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"\tf(x) = sum_i\n\tunderbracethetaleft(x-x_i^minright)thetaleft(x_i^max-xright)\n\tunderbracesum_j\n\tunderbraceF_ij(x mathbfa_ij)\n\t_textformula\n\t_textrule\n\t_textpiece","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"where theta(x) is the Heaviside step function. The functions F(x mathbfa) are the formulas, that take a set of parameters mathbfa. The Formula object holds the function F together with constraints regarding its applicability with the parameters mathbfa in a given interval. The quantity sum_jF_ij(x mathbfa_ij) is the rule that computes the value, given x [1]. The parameters mathbfa are in general different in each piece, but the function F may be the same. For instance, the cubic-spline interpolation of a dataset could be represented as a PiecewiseFunction object in which all formulas are 3rd-order polynomials F(x mathbfa_i) = a_i1+a_i2x+a_i3x^2+a_i4x^3. The piece contains the rule and the interval defined by x_i^min and x_i^max.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"[1]: The use of several formulas in a piece is therefore limited to function types for which a + method exists.","category":"page"},{"location":"index.html#Typical-use","page":"Piecewise","title":"Typical use","text":"","category":"section"},{"location":"index.html#Encoding-computer-intensive-functions","page":"Piecewise","title":"Encoding computer-intensive functions","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Consider a function f(x) that is computationally intensive. If formulas F(x mathbfa) exist, that can approximate f(x) in restricted domains to a high accuracy, then f(x) can be encoded in a fast PiecewiseFunction object. This is useful if the function f(x) is just one part of a bigger calculation that requires computing f(x) many times. The use of arbitrary functions as formulas allows one to represent behaviors, such as power laws or neighborhood of singularities, that are not well described by polynomial interpolations.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"tip: Tip\nThe module Piecewise provides the method piecewisefit for constructing a piecewise approximation of a real-valued function f(x) to a user-specified accuracy, using user-specified formulas.","category":"page"},{"location":"index.html#Fast-integral-transforms","page":"Piecewise","title":"Fast integral transforms","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A piecewise representation of f(x) with well-chosen formulas enables one to perform fast integral transforms of f. An integral transform with kernel K is defined as","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"\t(Kcirc f)(mathbfX) = int_-infty^inftydxf(x) K(x mathbfX)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"where mathbfX represents a variable or a set of variables and K(x mathbfX) is the kernel. If f(x) can be accurately piecewise-approximated by formulas F(x mathbfa) for which continuous primitive functions mathcalF_K(x mathbfa mathbfX) over the kernel K are known, i.e,","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"\tfracddxmathcalF_K(x mathbfa mathbfX)\n\t= F(x mathbfa) K(x mathbfX)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"then the integral transform can be immediately evaluated as","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"\t(Kcirc f)(mathbfX) = sum_i\n\tthetaleft(x-x_i^minright)thetaleft(x_i^max-xright)\n\tsum_jleftmathcalF_K_ij(x_i^max mathbfa_ij mathbfX) - mathcalF_K_ij(x_i^min  mathbfa_ij mathbfX)right","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A simple example of kernel is K(xn)=x^n, which provides the n-th moment of the function f(x) defined as (Mcirc f)(n) = int_-infty^inftydxf(x)x^n. Other important examples include the Fourier transform with K(x k)=e^-ikx for kinmathbbR, the Laplace transform with K(x s)=theta(x)e^-sx for sinmathbbC, or the Hilbert transform with kernel K(x z)=1(z-x) for zinmathbbCsetminusmathbbR, which also yields the Kramers-Kronig transform.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"tip: Tip\nThe module Piecewise provides a generic integral transform that can work with user-defined primitives mathcalF_K(x mathbfa mathbfX). It also provides several Formula objects with primitives for the kernel x^n (see Formulas). The module PiecewiseHilbert adds to these formulas the primitives needed for the Hilbert transform. The module PiecewiseLorentz adds the primitives needed for what we call the Lorentz transform.","category":"page"},{"location":"index.html#Types","page":"Piecewise","title":"Types","text":"","category":"section"},{"location":"index.html#PiecewiseFunction","page":"Piecewise","title":"PiecewiseFunction","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A piecewise function can be initialized as:","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"f = PiecewiseFunction([parity,] pieces)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Once initialized, the piecewise function can be evaluated as f(x). The optional argument parity can be either :none (default), :even, or :odd. If :even or :odd parities are specified, the piecewise function evaluates according to f(x0) = pm f(-x), respectively [2]. The argument pieces is an object of type Piece or an array of such objects.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"[2]: This limits the use of :odd to function types for which a - method exists.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Arithmetic operations with scalars are possible, e.g., s + f or s * f yield new piecewise functions appropriately transformed. Two piecewise functions can be merged by adding them with + (or sum() for an array).","category":"page"},{"location":"index.html#piecesection","page":"Piecewise","title":"Piece","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A piece is characterized by a domain and a rule to return a value. This rule is an object of type Formula or an array of such objects, accompanied by parameters:","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"p = Piece(domain[, included], rule, parameters)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The argument domain::Tuple{Real, Real} with domain[1] <= domain[2] specifies the domain of the piece. The optional argument included::Tuple{Bool, Bool}, by default (true, true),  indicates whether the domain boundaries are included in the domain (see Domains and boundaries). If the argument rule is of type Formula, the argument parameters must be of type Vector{Any}, while if rule is of type Vector{Formula}, parameters must be of type Vector{Vector{Any}}. When several formulas are provided, the rule is the sum of all formulas [1].","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A piece can also be initialized with a single function as","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"p = Piece(domain[, included], function)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The argument function is a function with interface function(::Real). It can also be passed as a string representing an anonymous function. This method of initialization is equivalent to p = Piece(domain, [included,] Formula(2, (x, a) -> a[2] * function(a[1] * x)), [1.0, 1.0]). The parameters a[1] and a[2] are added for the function to behave correctly under the default scaling and mirroring (see Formula).","category":"page"},{"location":"index.html#formulasection","page":"Piecewise","title":"Formula","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"An object of type Formula is created as","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"F = Formula([name,] params, value[, check][, scale][, mirror])","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The optional argument name::String is used for printout purposes. In particular, it allows the method format to replace the function by its name. The argument params::Integer specifies the number of parameters in the formula. If it is positive, the formula takes exactly params parameters; if it is negative, the formula takes at most -param parameters. This allows one to define formulas using functions with an unspecified number of parameters, as e.g. polynomials of various orders (see POLY and piecewisefit). The argument value::Function is a function with interface value(x::Real, a::Vector{Any}) that returns a value given x and the array of parameters a. If value is an anonymous function, the code defining that function is not stored in the Formula object and thus cannot be printed by the method format. For that reason, it is also possible to pass value as a string representing an anonymous function.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The optional argument check::Function is a function defined as check(a, domain, included, danger, fatal). This function must return true if the parameters a can be used in the function value(x, a) for x in the domain specified by the arguments domain and included (see Piece), and false otherwise. The arguments danger::Bool and fatal::Bool should be used to switch on and off warning and error messages, respectively (see Example in Formula). By default, check = (a, domain, included, danger, fatal) -> true, which means that no check is performed.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The optional argument scale::Function is a function with interface scale(a::Vector{Any}, s::Number) that returns the parameters of the formula after multiplication by the scalar s. By default, scale = (a, s) -> [a[1:end-1]..., a[end] * s], which means that only the last parameter is scaled. The optional argument mirror::Function is a function with interface mirror(a::Vector{Any}) that returns the parameters of the formula after even reflection through x=0. By default, mirror = a -> [-a[1], a[2:end]...], which means that the first parameter is negated and the others are unchanged.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"warning: Warning\nIf the arguments value, check, scale, and mirror are function names (rather than anonymous functions), the function name is stored in the structure Formula, not the function definition. If the function is redefined after the Formula object has been created, that object will use the new function.","category":"page"},{"location":"index.html#Domains-and-boundaries","page":"Piecewise","title":"Domains and boundaries","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The following rules determine which value is returned by the method PiecewiseFunction(x).","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The value 0 is returned if x does not belong to any of the domains defined in PiecewiseFunction.pieces, with two exceptions:\nThe value Inf is returned if x coincides with the common boundary of two domains (this boundary being excluded from both domains) and if the rules for x-ϵ and x+ϵ both yield positive values, where ϵ = 10 *  eps(Float64) [3].\nThe value -Inf is returned in the same situation if the rules for x-ϵ and x+ϵ both yield negative values [3].\nIf x coincides with the common boundary of two domains and if this boundary is included in both domains, the rule of the leftmost domain is used.\nIf x falls inside the domain of a piece, the rule of that piece is used.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"[3]: This limits the treatment of singularities to function types for which a sign method exists.","category":"page"},{"location":"index.html#Main-methods","page":"Piecewise","title":"Main methods","text":"","category":"section"},{"location":"index.html#integraltransform","page":"Piecewise","title":"integraltransform","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A function returning the integral transform of the piecewise function f may be created as:","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Kof(X) = integraltransform(f::PiecewiseFunction, X::Any)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"This assumes that for each Formula object F used in the pieces of f, there is a method F.value(x::Real, a::Vector{Any}, X::Any) returning the primitive of F.value(x, a) * K(x, X) for the kernel K of interest (see Fast integral transforms). If the function f is :even or :odd, the method integraltransform requires instead a method F.value(s, x::Real, a::Vector{Any}, X::Any) with s = 1 or s = -1, respectively, which returns the primitive of F.value(x, a) * (K(x, X) + s * K(-x, X)).","category":"page"},{"location":"index.html#moment","page":"Piecewise","title":"moment","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The moment of order n of the piecewise function f may be obtained as","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"m = moment(f::PiecewiseFunction, n::Integer)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"This assumes that for each Formula object F used in the pieces of f, there is a method F.value(x::Real, a::Vector{Any}, n::Integer) returning the primitive of F.value(x, a) * x^n. The argument n must be a non-negative integer.","category":"page"},{"location":"index.html#piecewisefitsection","page":"Piecewise","title":"piecewisefit","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Given a function g(x), a PiecewiseFunction object approximating this function can be constructed as:","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"f = piecewisefit(g, domain, formulas; kwargs...)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The argument g(::Real) is the function to approximate. The algorithm tries to fit any linear superposition of the formulas given in the argument formulas::Vector{Formula} to g(x) in the domain specified by the argument domain::Tuple{Real, Real}. The fit is successful if it matches the function within a specified tolerance and if the fitted parameters pass the tests implemented in the method F.check of each Formula object used. If the fit is unsuccessful, the domain is divided in two and the algorithm continues recursively in each sub-domain. The recursion uses the available threads, although the parallelism isn't optimal yet.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The argument formulas can hold several Formula objects with fixed number of parameters and at most one Formula object with a variable number of parameters. The formulas with fixed number of parameters are tried first, then the one with variable number of parameters, if any, progressively increasing the number of parameters up to the maximum number allowed. Then pairwise linear combinations are tried, and so on until one combination succeeds.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"If the function g(x) is noiseless, the algorithm should converge with relatively large sub-domains. If g(x) has numerical noise, the algorithm will likely be trapped trying to piecewise-fit that noise. To avoid this, a minimal sub-domain size may be specified with the optional argument grain. If grain > eps(Float64), the algorithm returns the best possible fit in sub-domains of typical size grain. If no fit is successful, or if grain = eps(Float64), the algorithm returns a Piece object that uses either the function g(x) if the optional argument loop is true, or a linear interpolation of g(x) across the domain if it is false (default). On the other hand, relevant rapid variations of g(x) may be missed by the algorithm, because it tries to minimize the number of calls to g(x). The optional argument resolution allows one to control how finely the function g(x) is sampled.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Because piecewisefit operates independently in each piece, the fitted function f(x) may display small discontinuities at the boundaries of the domains, despite g(x) being continuous there. To try and enforce approximate continuity, sampling points are introduced at the boundaries to better constrain the fitting.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The optional keyword arguments are:","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"parity::Symbol: imposes a given parity (:even or :odd) to the PiecewiseFunction object (by default parity = :none)\nsingularities::Vector{Real}: values of x that are treated as singularities, i.e., excluded from any sub-domain generated during the recursion (by default singularities = [])\ncuts::Vector{Real}: values of x that are forced to be piece boundaries (by default cuts = [])\ngrain::Real: sub-domains of size smaller than grain are not split further by the algorithm (by default grain = eps(Float64))\nresolution::Real: no fit is accepted before sampling the function g(x) in each sub-domain with at most a distance resolution between successive points (by default resolution = Inf)\nrtol::Real, atol::Real: a fit is successful if abs(dg) < rtol * abs(g) + atol, where dg are the residuals and g are the function values (by default rtol = 0, atol=eps(Float64))\nloop::Bool: if true, the returned PiecewiseFunction object uses the function g(x) in sub-domains where the fit fails, otherwise it uses a linear interpolation of g(x) across the sub-domain (by default loop = false).","category":"page"},{"location":"index.html#Example","page":"Piecewise","title":"Example","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The following example adds PiecewiseFunction objects to display the Cantor set.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing ..Piecewise # hide\n# Rule to construct the set\ncut(d) = [(d[1], d[1] + 1//3 * (d[2] - d[1])),\n    (d[1] + 2//3 * (d[2] - d[1]), d[2])]\nset(n) = n == 0 ? [(0, 1)] : vcat(cut.(set(n - 1))...)\n\n# Piecewise function at order n\ncantor(n) = PiecewiseFunction([Piece(d, x -> exp(-n / 3)) for d in set(n)])\n\n# Plot sum of piecewise functions\nusing Plots\n# Define array x with all breakpoints\nx = vcat(map(b -> [b - eps(Float64), b + eps(Float64)],\n    vcat(map(d -> [d[1], d[2]], set(6))...))...)\nplot(x, sum([cantor(n) for n = 0:6]).(x),\n    f=(0, 0, :black), linewidth=0, axis=false, grid=false, legend=:none)\nsavefig(\"cantor.svg\"); nothing # hide","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"(Image: )","category":"page"},{"location":"index.html#Formulas","page":"Piecewise","title":"Formulas","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The module Piecewise provides several Formula objects with appropriate primitives for computing the moments of a piecewise function. In the descriptions below, x_min and x_max refer to the boundaries of the domain in which the formula is used and _2F_1(abcz) refers to the hypergeometric function. This function has a branch cut on the real axis z=xinmathbbR for x1. In all cases considered here, _2F_1(abcx) refers to the value below the cut, i.e., _2F_1(abcx-i0).","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"POLY |  TAIL |  LOG | ISRS | PLS | XLOG | XISRS","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"","category":"page"},{"location":"index.html#POLY","page":"Piecewise","title":"POLY","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Polynomial of varying order\n1 to 13 parameters","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The function POLY.value(x, a) is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"F(xmathbfa) = sum_i=1^k a_i x^i-1","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"where the number of parameters can vary in the range 1leqslant kleqslant 13. The order of the polynomial is limited to 12 in order to reduce numerical instabilities. The parameters a_i are unrestricted.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The primitive function for the moment of order n is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"mathcalF(xmathbfan) = sum_i=1^k fraca_ii+n x^i+n","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"This primitive is continuous for xinmathbbR.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"","category":"page"},{"location":"index.html#TAIL","page":"Piecewise","title":"TAIL","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Rational function approaching zero as 1x or 1x^2 at infinity\n5 parameters","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The function TAIL.value(x, a) is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"F(xmathbfa) = fraca_1+a_2xa_3+a_4x+a_5x^2","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The parameters must satisfy either a_4^2-4a_3a_5  0, such that the zeros of the denominator are not on the real axis, or they must ensure that the two zeros x_pm=frac12a_5left(-a_4pmsqrta_4^2-4a_3a_5right) lie outside the domain.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The primitive function for the moment of order n is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"beginalign*\nmathcalF(xmathbfan) = fracx^n+12(n+1)a_3Deltaleft\nleft2a_2a_3-a_1left(a_4-Deltaright)right\n_2F_1left(1n+1n+2frac-2a_5xa_4+Deltaright)right\nquadleft-left2a_2a_3-a_1left(a_4+Deltaright)right\n_2F_1left(1n+1n+2frac-2a_5xa_4-Deltaright)right\nendalign*","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"where Delta=sqrta_4^2-4a_3a_5. Simpler expressions are used if, e.g., a_3=0. This primitive is continuous for xinmathbbR, except at the zeros x=x_pm, if they are on the real axis.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"","category":"page"},{"location":"index.html#LOG","page":"Piecewise","title":"LOG","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Logarithmic singularity\n2 parameters","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The function LOG.value(x, a) is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"F(xmathbfa) = a_2lnx-a_1","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The domain should not include the point x=a_1.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The primitive function for the moment of order n is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"mathcalF(xmathbfan) = fraca_2x^n+1(n+1)(n+2)a_1left\n(n+2)a_1lnx-a_1+_2F_1left(1n+2n+3fracxa_1right)xright","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A simpler expression is used if a_1=0. This primitive is continuous in any domain excluding x=a_1.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"","category":"page"},{"location":"index.html#ISRS","page":"Piecewise","title":"ISRS","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Inverse square-root singularity\n2 parameters","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The function ISRS.value(x, a) is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"F(xmathbfa) = fraca_2sqrtx^2-a_1^2","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The domain should not include any of the points x=pm a_1.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The primitive function for the moment of order n is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"mathcalF(xmathbfan) = fraca_2x^n+1(n+1)sqrtx^2-a_1^2\nsqrt1-left(fracxa_1right)^2_2F_1left(frac12fracn+12\nfracn+32left(fracxa_1right)^2right)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A simpler expression is used if a_1=0. This primitive is continuous in any domain excluding x=pm a_1.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"","category":"page"},{"location":"index.html#PLS","page":"Piecewise","title":"PLS","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Power-law singularity\n3 parameters","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The function PLS.value(x, a) is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"F(xmathbfa) = a_3x-a_1^a_2","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The parameter a_1 must be outside the domain, i.e. a_1leqslant x_min or a_1geqslant x_max, with the equal sign allowed only if a_2geqslant0. The exponent a_2 must be in the range -12 12 (to reduce numerical instabilities like in POLY).","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The primitive function for the moment of order n is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"mathcalF(xmathbfan) = fraca_3x-a_1^a_2x^n+1n+1\nleft(1-fracxa_1right)^-a_2\n_2F_1left(n+1-a_2n+2fracxa_1right)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A simpler expression is used if a_1=0. This primitive is continuous in any domain excluding x=a_1.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"","category":"page"},{"location":"index.html#XLOG","page":"Piecewise","title":"XLOG","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Logarithmic singularity times x\n2 parameters","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The function XLOG.value(x, a) is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"F(xmathbfa) = a_2xlnx-a_1","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The domain should not include the point x=a_1.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The primitive function for the moment of order n is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"mathcalF(xmathbfan) = fraca_2x^n+2(n+2)(n+3)a_1left\n(n+3)a_1lnx-a_1+_2F_1left(1n+3n+4fracxa_1right)xright","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A simpler expression is used if a_1=0. This primitive is continuous in any domain excluding x=a_1.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"","category":"page"},{"location":"index.html#XISRS","page":"Piecewise","title":"XISRS","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Inverse square-root singularity times x\n2 parameters","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The function XISRS.value(x, a) is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"F(xmathbfa) = fraca_2xsqrtx^2-a_1^2","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The domain should not include any of the points x=pm a_1.","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"The primitive function for the moment of order n is","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"mathcalF(xmathbfan) = fraca_2x^n+2(n+2)sqrtx^2-a_1^2\nsqrt1-left(fracxa_1right)^2_2F_1left(frac12fracn2+1\nfracn2+2left(fracxa_1right)^2right)","category":"page"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"A simpler expression is used if a_1=0. This primitive is continuous in any domain excluding x=pm a_1.","category":"page"},{"location":"index.html#Public-interface","page":"Piecewise","title":"Public interface","text":"","category":"section"},{"location":"index.html#Index","page":"Piecewise","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Piecewise","title":"Piecewise","text":"Pages   = [\"index.md\"]\nModules = [Piecewise]\nOrder   = [:type, :constant, :function]","category":"page"},{"location":"index.html#Types-2","page":"Piecewise","title":"Types","text":"","category":"section"},{"location":"index.html#Piecewise.Formula","page":"Piecewise","title":"Piecewise.Formula","text":"Formula([name::String,] params::Integer, value::Function\n    [, check::Function][, scale::Function][, mirror::Function])\n\nReturn a Formula object with an optional name.\n\nThe Formula takes exactly params parameters if params >= 0 and at most -params parameters if params < 0. The value of the formula is set by the function value(::Real, ::Vector{Any}). The optional function check(a::Vector{Any}, domain::Tuple{Real, Real}, included::Tuple{Bool, Bool}, danger::Bool, fatal::Bool) must return true or false, depending on whether the function value(x, a) is valid in the domain specified by domain and included (see Piece) with the parameters a. Warnings must be issued by check only if danger is true and errors must be thrown only if fatal is true. The optional function scale(a::Vector{Any}, s::Number) must return the parameters after multiplication of the formula by s, by default scale = (a, s) -> [a[1:end-1]..., a[end] * s]. The optional function mirror(a::Vector{Any}) must return the parameters after even reflection of the formula through x=0, by default mirror = a -> [-a[1], a[2:end]...].\n\nFields\n\nname::String\nparams::Integer\nvalue::Function\ncheck::Function\nscale::Function\nmirror::Function\n\nExample\n\nThis creates a square-root singularity:\n\njulia> srs(x, a) = a[2] * sqrt(x - a[1]);\n\njulia> function srs(a, domain, included, danger, fatal)\n           t = domain[1] > a[1] || (domain[1] == a[1] && ! included[1])\n           !t && fatal && throw(ArgumentError(\"Singularity must be at left of domain.\"))\n           t || return false\n           t = a[2] >= 0\n           !t && danger && @warn \"Negative singularity in domain $(domain).\"\n           return true\n       end;\n\njulia> F = Formula(\"SRS\", 2, srs, srs)\nFormula(\"SRS\", 2, srs, srs)\n\njulia> F.check([1, 1], (0, 2), (true, true), true, false)\nfalse\n\njulia> F.check([-1, -1], (0, 2), (true, true), true, false)\n┌ Warning: Negative singularity in domain (0, 2).\n└ @ Main REPL[3]:6\ntrue\n\n\n\n\n\n","category":"type"},{"location":"index.html#Piecewise.Piece","page":"Piecewise","title":"Piecewise.Piece","text":"Piece(domain[, included=(true, true)], rule, parameters)\n\nReturn a Piece object in the domain domain::Tuple{Real, Real}.\n\nThe argument included tells whether the domain boundaries belong to the domain. The arguments rule::Vector{Formula} and parameters::Vector{Vector{Any}} specify the rule used to evaluate the value of the piece (see Formula). For a single formula, it is also possible to pass rule::Formula and parameters::Vector{Any}.\n\nPiece(domain[, included=(true, true)], function)\n\nInitialization with a single function. This is equivalent to Piece(domain[, included], Formula(0, (x, a) -> function(x)), Any[]).\n\nFields\n\ndomain::Tuple{Real, Real}\nincluded::Tuple{Bool, Bool}\nrule::Vector{Formula}\nparameters::Vector{Vector{Any}}\n\nExamples\n\nThis represents 1x for strictly positive numbers:\n\njulia> Piece((0, Inf), (false, true), x -> 1 / x)\n< Piece of type unnamed in the domain ]0.0, Inf] >\n\n\nThis represents -logx for xin 0 1:\n\njulia> Piece((0, 1), (false, true), Formula(\"LOG\", 1, (x, a) -> a[1] * log(abs(x))), [-1])\n< Piece of type LOG in the domain ]0.0, 1.0] >\n\n\n\n\n\n\n","category":"type"},{"location":"index.html#Piecewise.PiecewiseFunction","page":"Piecewise","title":"Piecewise.PiecewiseFunction","text":"PiecewiseFunction([parity=:none,] pieces::Vector{Piece})\n\nReturn a PiecewiseFunction object.\n\nThe optional argument parity can be :none, :even, or :odd. The argument pieces contains the various pieces (see Piece). It is also possible to pass a single piece as pieces::Piece.\n\nFields\n\nparity::Symbol\npieces::Vector{Piece}\n\nExample\n\nThis represents the Cauchy principal value of 1x:\n\njulia> f = PiecewiseFunction(:odd, Piece((0, Inf), (false, true), x -> 1 / x))\n< Piecewise odd function with 1 piece and support [-Inf, Inf] >\n\njulia> f.([-1, 0, 1])\n3-element Vector{Real}:\n -1.0\n  0\n  1.0\n\n\n\n\n\n\n","category":"type"},{"location":"index.html#Constants","page":"Piecewise","title":"Constants","text":"","category":"section"},{"location":"index.html#Piecewise.POLY","page":"Piecewise","title":"Piecewise.POLY","text":"Polynomial of varying order (1 to 13 parameters)\n\nF(xmathbfa) = sum_i=1^n a_i x^i-1\n\n\n\n\n\n","category":"constant"},{"location":"index.html#Piecewise.TAIL","page":"Piecewise","title":"Piecewise.TAIL","text":"Rational function approaching zero as 1x or 1x^2 at infinity (5 parameters)\n\nF(xmathbfa) = fraca_1+a_2xa_3+a_4x+a_5x^2\n\n\n\n\n\n","category":"constant"},{"location":"index.html#Piecewise.LOG","page":"Piecewise","title":"Piecewise.LOG","text":"Logarithmic singularity (2 parameters)\n\nF(xmathbfa) = a_2lnx-a_1\n\n\n\n\n\n","category":"constant"},{"location":"index.html#Piecewise.ISRS","page":"Piecewise","title":"Piecewise.ISRS","text":"Inverse square-root singularity (2 parameters)\n\nF(xmathbfa) = fraca_2sqrtx^2-a_1^2\n\n\n\n\n\n","category":"constant"},{"location":"index.html#Piecewise.PLS","page":"Piecewise","title":"Piecewise.PLS","text":"Power-law singularity (3 parameters)\n\nF(xmathbfa) = a_3x-a_1^a_2\n\n\n\n\n\n","category":"constant"},{"location":"index.html#Piecewise.XLOG","page":"Piecewise","title":"Piecewise.XLOG","text":"Logarithmic singularity times x (2 parameters)\n\nF(xmathbfa) = a_2xlnx-a_1\n\n\n\n\n\n","category":"constant"},{"location":"index.html#Piecewise.XISRS","page":"Piecewise","title":"Piecewise.XISRS","text":"Inverse square-root singularity times x (2 parameters)\n\nF(xmathbfa) = fraca_2xsqrtx^2-a_1^2\n\n\n\n\n\n","category":"constant"},{"location":"index.html#Methods","page":"Piecewise","title":"Methods","text":"","category":"section"},{"location":"index.html#Piecewise.domains","page":"Piecewise","title":"Piecewise.domains","text":"domains(f::PiecewiseFunction)\n\nReturn the domains of the piecewise function f as a Vector{Tuple{Real, Real}}.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Piecewise.intervals","page":"Piecewise","title":"Piecewise.intervals","text":"intervals(f::PiecewiseFunction)\n\nReturn a Vector{String} representing the domains and boundaries of the piecewise function f.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Piecewise.support","page":"Piecewise","title":"Piecewise.support","text":"support(f::PiecewiseFunction)\n\nReturn the support of the piecewise function f as a Tuple{Real, Real}.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Piecewise.singularities","page":"Piecewise","title":"Piecewise.singularities","text":"singularities(f::PiecewiseFunction)\n\nReturn the singularities of the piecewise function f as a Vector{Real}.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Piecewise.formulas","page":"Piecewise","title":"Piecewise.formulas","text":"formulas(f::PiecewiseFunction)\n\nReturn the formula names used in the piecewise function f as a Vector{String}. \n\n\n\n\n\n","category":"function"},{"location":"index.html#Piecewise.integraltransform","page":"Piecewise","title":"Piecewise.integraltransform","text":"integraltransform(f::PiecewiseFunction, X::Any)\n\nReturn the integral transform of the piecewise function f, defined as\n\n(Kcirc f)(mathbfX) = int_-infty^inftydxf(x)K(xmathbfX)\n\nThis method assumes that each function F(::Real, ::Vector{Any}) used in the piecewise function f has a method F(::Real, ::Vector{Any}, ::Any) that returns the primitive of F(x mathbfa) multiplied by the kernel K(x mathbfX), i.e., d/dx F(x, a, X) = F(x, a) * K(x, X). If f.parity is :even or :odd, integraltransform requires a method F(::Integer, ::Real, ::Vector{Any}, ::Any) such that d/dx F(1, x, a, X) = F(x, a) * (K(x, X) + K(-x, X)) and d/dx F(-1, x, a, X) = F(x, a) * (K(x, X) - K(-x, X)).\n\nExample\n\nThis define a Formula object LIN that can be used to represent any piecewise linear function, and such that integraltransform provides its Fourier transform:\n\njulia> F(x, a) = a[1] + a[2] * x;\n\njulia> LIN = Formula(\"LIN\", 2, F, (a, s) -> a * s, a -> [a[1], -a[2]]);\n\njulia> F(x, a, k) = (a[1] * k + a[2] * (k * x + im)) * exp(im * k * x)/(im * k^2);\n\njulia> F(s, x, a, k) = 2 * (s == 1 ? real(F(x, a, k)) : im * imag(F(x, a, k)));\n\njulia> f = PiecewiseFunction(:even, [Piece((0, π), LIN, [π, -1])])\n< Piecewise even function with 1 piece and support [-3.1416, 3.1416] >\n\njulia> integraltransform(f, 1)\n4.0\n\n\n\n\n\n","category":"function"},{"location":"index.html#Piecewise.moment","page":"Piecewise","title":"Piecewise.moment","text":"moment(f::PiecewiseFunction, n::Integer)\n\nReturn the moment of order n of the piecewise function f, defined as\n\n(Mcirc f)(n) = int_-infty^inftydxf(x)x^n\n\n\n\n\n\n","category":"function"},{"location":"index.html#Piecewise.piecewisefit","page":"Piecewise","title":"Piecewise.piecewisefit","text":"piecewisefit(f::Function, domain::Tuple{Real, Real}, formulas::Vector{Formula}; kwargs...)\n\nReturn a piecewise approximation of the real-valued function f(::Real) in the domain domain, using the formulas given in the array formulas (see Formula).\n\nOptional keyword arguments\n\nparity : Impose a parity (:even or :odd, default :none) to  the piecewise function\nsingularities : Points excluded from the domains (default Real[])\ncuts : Points forced to be piece boundaries (default Real[])\ngrain : Minimal domain size, default eps(Float64)\nresolution : Maximal distance between sampled points, default Inf\nrtol : Relative tolerance, default 0.0\natol : Absolute tolerance, default eps(Float64)\nloop : Whether to return f in case of failure in a domain, default false\n\nExample\n\nHere is a one-piece approximation to the function sin^-1(x). The power law at x=1 is represented exactly and a polynomial is fit to the rest:\n\njulia> f = PiecewiseFunction(:odd, Piece((0, 1), PLS, [1, 1 / 2, -sqrt(2)])) +\n           piecewisefit(x -> asin(x) + sqrt(2 - 2 * x), (0, 1), [POLY],\n           parity=:odd, atol=1e-5)\n< Piecewise odd function with 1 piece and support [-1.0, 1.0] >\n\njulia> max([abs(f(x) - asin(x)) for x in -1:0.1:1]...) < 1e-5\ntrue\n\n\n\n\n\n","category":"function"},{"location":"index.html#Printf.format","page":"Piecewise","title":"Printf.format","text":"format(f::PiecewiseFunction)\n\nReturn a string holding the constructor for the PiecewiseFunction object f. For Formula objects than have a name, the name is used instead of the constructor of the Formula object. Note that print(f) is equivalent to print(format(f)).\n\n\n\n\n\n","category":"function"}]
}
