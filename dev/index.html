<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Piecewise · Piecewise</title><meta name="title" content="Piecewise · Piecewise"/><meta property="og:title" content="Piecewise · Piecewise"/><meta property="twitter:title" content="Piecewise · Piecewise"/><meta name="description" content="Documentation for Piecewise."/><meta property="og:description" content="Documentation for Piecewise."/><meta property="twitter:description" content="Documentation for Piecewise."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Piecewise logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Piecewise</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Piecewise</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Typical-use"><span>Typical use</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Domains-and-boundaries"><span>Domains and boundaries</span></a></li><li><a class="tocitem" href="#Main-methods"><span>Main methods</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Formulas"><span>Formulas</span></a></li><li><a class="tocitem" href="#Public-interface"><span>Public interface</span></a></li></ul></li><li><a class="tocitem" href="hilbert.html">PiecewiseHilbert</a></li><li><a class="tocitem" href="lorentz.html">PiecewiseLorentz</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Piecewise</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Piecewise</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ChristopheBerthod/Piecewise.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Piecewise"><a class="docs-heading-anchor" href="#Piecewise">Piecewise</a><a id="Piecewise-1"></a><a class="docs-heading-anchor-permalink" href="#Piecewise" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The package can be installed with <code>Pkg.add</code>.</p><pre><code class="language-julia hljs">using Pkg; Pkg.add(&quot;Piecewise&quot;)</code></pre><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>A piecewise function of a real variable <span>$x$</span> returns a value computed with a formula that depends on the interval in which <span>$x$</span> lies. The <a href="https://julialang.org">Julia</a> module <a href="https://github.com/ChristopheBerthod/Piecewise.jl">Piecewise</a> represents such a function as a collection of <em>pieces</em>. Each piece is an object of type <a href="index.html#Piecewise.Piece"><code>Piece</code></a> that contains an interval and a rule to compute a value, given <span>$x$</span>. The rule is expressed by <em>formulas</em>, that are contained in objects of type <a href="index.html#Piecewise.Formula"><code>Formula</code></a>.</p><p>In mathematical terms, a piecewise function can be written as</p><p class="math-container">\[	f(x) = \sum_i
	\underbrace{\theta\left(x-x_i^{\min}\right)\theta\left(x_i^{\max}-x\right)
	\underbrace{\sum_j
	\underbrace{F_{ij}(x, \mathbf{a}_{ij})}
	_{\text{formula}}}
	_{\text{rule}}}
	_{\text{piece}},\]</p><p>where <span>$\theta(x)$</span> is the <a href="https://en.wikipedia.org/wiki/Heaviside_step_function">Heaviside step function</a>. The functions <span>$F(x, \mathbf{a})$</span> are the <em>formulas</em>, that take a set of parameters <span>$\mathbf{a}$</span>. The <a href="index.html#Piecewise.Formula"><code>Formula</code></a> object holds the function <span>$F$</span> together with constraints regarding its applicability with the parameters <span>$\mathbf{a}$</span> in a given interval. The quantity <span>$\sum_jF_{ij}(x, \mathbf{a}_{ij})$</span> is the rule that computes the value, given <span>$x$</span> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. The parameters <span>$\mathbf{a}$</span> are in general different in each piece, but the function <span>$F$</span> may be the same. For instance, the cubic-spline interpolation of a dataset could be represented as a <a href="index.html#PiecewiseFunction"><code>PiecewiseFunction</code></a> object in which all formulas are 3rd-order polynomials <span>$F(x, \mathbf{a}_i) = a_{i1}+a_{i2}x+a_{i3}x^2+a_{i4}x^3$</span>. The <em>piece</em> contains the rule and the interval defined by <span>$x_i^{\min}$</span> and <span>$x_i^{\max}$</span>.</p><h2 id="Typical-use"><a class="docs-heading-anchor" href="#Typical-use">Typical use</a><a id="Typical-use-1"></a><a class="docs-heading-anchor-permalink" href="#Typical-use" title="Permalink"></a></h2><h5 id="Encoding-computer-intensive-functions"><a class="docs-heading-anchor" href="#Encoding-computer-intensive-functions">Encoding computer-intensive functions</a><a id="Encoding-computer-intensive-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Encoding-computer-intensive-functions" title="Permalink"></a></h5><p>Consider a function <span>$f(x)$</span> that is computationally intensive. If formulas <span>$F(x, \mathbf{a})$</span> exist, that can approximate <span>$f(x)$</span> in restricted domains to a high accuracy, then <span>$f(x)$</span> can be encoded in a fast <a href="index.html#PiecewiseFunction"><code>PiecewiseFunction</code></a> object. This is useful if the function <span>$f(x)$</span> is just one part of a bigger calculation that requires computing <span>$f(x)$</span> many times. The use of arbitrary functions as formulas allows one to represent behaviors, such as power laws or neighborhood of singularities, that are not well described by polynomial interpolations.</p><div class="admonition is-success" id="Tip-23656242bb7509a7"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-23656242bb7509a7" title="Permalink"></a></header><div class="admonition-body"><p>The module <a href="https://github.com/ChristopheBerthod/Piecewise.jl">Piecewise</a> provides the method <a href="index.html#piecewisefitsection"><code>piecewisefit</code></a> for constructing a piecewise approximation of a real-valued function <span>$f(x)$</span> to a user-specified accuracy, using user-specified formulas.</p></div></div><h5 id="Fast-integral-transforms"><a class="docs-heading-anchor" href="#Fast-integral-transforms">Fast integral transforms</a><a id="Fast-integral-transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-integral-transforms" title="Permalink"></a></h5><p>A piecewise representation of <span>$f(x)$</span> with well-chosen formulas enables one to perform fast <a href="https://en.wikipedia.org/wiki/Integral_transform"><strong>integral transforms</strong></a> of <span>$f$</span>. An integral transform with kernel <span>$K$</span> is defined as</p><p class="math-container">\[	(K\circ f)(\mathbf{X}) = \int_{-\infty}^{\infty}dx\,f(x) K(x, \mathbf{X}),\]</p><p>where <span>$\mathbf{X}$</span> represents a variable or a set of variables and <span>$K(x, \mathbf{X})$</span> is the kernel. If <span>$f(x)$</span> can be accurately piecewise-approximated by formulas <span>$F(x, \mathbf{a})$</span> for which continuous <a href="https://en.wikipedia.org/wiki/Antiderivative">primitive functions</a> <span>$\mathcal{F}_K(x, \mathbf{a}, \mathbf{X})$</span> over the kernel <span>$K$</span> are known, i.e,</p><p class="math-container">\[	\frac{d}{dx}\mathcal{F}_K(x, \mathbf{a}, \mathbf{X})
	= F(x, \mathbf{a}) K(x, \mathbf{X}),\]</p><p>then the integral transform can be immediately evaluated as</p><p class="math-container">\[	(K\circ f)(\mathbf{X}) = \sum_i
	\theta\left(x-x_i^{\min}\right)\theta\left(x_i^{\max}-x\right)
	\sum_j\left[{\mathcal{F}_K}_{ij}(x_i^{\max}, \mathbf{a}_{ij}, \mathbf{X}) - {\mathcal{F}_K}_{ij}(x_i^{\min},  \mathbf{a}_{ij}, \mathbf{X})\right].\]</p><p>A simple example of kernel is <span>$K(x,n)=x^n$</span>, which provides the <span>$n$</span>-th moment of the function <span>$f(x)$</span> defined as <span>$(M\circ f)(n) = \int_{-\infty}^{\infty}dx\,f(x)x^n$</span>. Other important examples include the Fourier transform with <span>$K(x, k)=e^{-ikx}$</span> for <span>$k\in\mathbb{R}$</span>, the Laplace transform with <span>$K(x, s)=\theta(x)e^{-sx}$</span> for <span>$s\in\mathbb{C}$</span>, or the Hilbert transform with kernel <span>$K(x, z)=1/(z-x)$</span> for <span>$z\in\mathbb{C}\setminus\mathbb{R}$</span>, which also yields the <a href="https://en.wikipedia.org/wiki/Kramers–Kronig_relations">Kramers-Kronig transform</a>.</p><div class="admonition is-success" id="Tip-f480ba78cf4e0265"><header class="admonition-header">Tip<a class="admonition-anchor" href="#Tip-f480ba78cf4e0265" title="Permalink"></a></header><div class="admonition-body"><p>The module <a href="https://github.com/ChristopheBerthod/Piecewise.jl">Piecewise</a> provides a generic integral transform that can work with user-defined primitives <span>$\mathcal{F}_K(x, \mathbf{a}, \mathbf{X})$</span>. It also provides several <a href="index.html#Piecewise.Formula"><code>Formula</code></a> objects with primitives for the kernel <span>$x^n$</span> (see <a href="index.html#Formulas">Formulas</a>). The module <a href="hilbert.html#PiecewiseHilbert">PiecewiseHilbert</a> adds to these formulas the primitives needed for the Hilbert transform. The module <a href="lorentz.html#PiecewiseLorentz">PiecewiseLorentz</a> adds the primitives needed for what we call the Lorentz transform.</p></div></div><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h5 id="PiecewiseFunction"><a class="docs-heading-anchor" href="#PiecewiseFunction"><code>PiecewiseFunction</code></a><a id="PiecewiseFunction-1"></a><a class="docs-heading-anchor-permalink" href="#PiecewiseFunction" title="Permalink"></a></h5><p>A piecewise function can be initialized as:</p><pre><code class="nohighlight hljs">f = PiecewiseFunction([parity,] pieces)</code></pre><p>Once initialized, the piecewise function can be evaluated as <code>f(x)</code>. The optional argument <code>parity</code> can be either <code>:none</code> (default), <code>:even</code>, or <code>:odd</code>. If <code>:even</code> or <code>:odd</code> parities are specified, the piecewise function evaluates according to <span>$f(x&lt;0) = \pm f(-x)$</span>, respectively <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>. The argument <code>pieces</code> is an object of type <a href="index.html#Piecewise.Piece"><code>Piece</code></a> or an array of such objects.</p><p>Arithmetic operations with scalars are possible, e.g., <code>s + f</code> or <code>s * f</code> yield new piecewise functions appropriately transformed. Two piecewise functions can be merged by adding them with <code>+</code> (or <code>sum()</code> for an array).</p><h5 id="piecesection"><a class="docs-heading-anchor" href="#piecesection"><code>Piece</code></a><a id="piecesection-1"></a><a class="docs-heading-anchor-permalink" href="#piecesection" title="Permalink"></a></h5><p>A piece is characterized by a domain and a rule to return a value. This rule is an object of type <a href="index.html#Piecewise.Formula"><code>Formula</code></a> or an array of such objects, accompanied by parameters:</p><pre><code class="nohighlight hljs">p = Piece(domain[, included], rule, parameters)</code></pre><p>The argument <code>domain::Tuple{Real, Real}</code> with <code>domain[1] &lt;= domain[2]</code> specifies the domain of the piece. The optional argument <code>included::Tuple{Bool, Bool}</code>, by default <code>(true, true)</code>,  indicates whether the domain boundaries are included in the domain (see <a href="index.html#Domains-and-boundaries">Domains and boundaries</a>). If the argument <code>rule</code> is of type <a href="index.html#Piecewise.Formula"><code>Formula</code></a>, the argument <code>parameters</code> must be of type <code>Vector{Any}</code>, while if <code>rule</code> is of type <code>Vector{Formula}</code>, <code>parameters</code> must be of type <code>Vector{Vector{Any}}</code>. When several formulas are provided, the rule is the sum of all formulas <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.</p><p>A piece can also be initialized with a single function as</p><pre><code class="nohighlight hljs">p = Piece(domain[, included], function)</code></pre><p>The argument <code>function</code> is a function with interface <code>function(::Real)</code>. It can also be passed as a string representing an anonymous function. This method of initialization is equivalent to <code>p = Piece(domain, [included,] Formula(2, (x, a) -&gt; a[2] * function(a[1] * x)), [1.0, 1.0])</code>. The parameters <code>a[1]</code> and <code>a[2]</code> are added for the function to behave correctly under the default scaling and mirroring (see <a href="index.html#formulasection"><code>Formula</code></a>).</p><h5 id="formulasection"><a class="docs-heading-anchor" href="#formulasection"><code>Formula</code></a><a id="formulasection-1"></a><a class="docs-heading-anchor-permalink" href="#formulasection" title="Permalink"></a></h5><p>An object of type <a href="index.html#Piecewise.Formula"><code>Formula</code></a> is created as</p><pre><code class="nohighlight hljs">F = Formula([name,] params, value[, check][, scale][, mirror])</code></pre><p>The optional argument <code>name::String</code> is used for printout purposes. In particular, it allows the method <a href="index.html#Printf.format"><code>format</code></a> to replace the function by its name. The argument <code>params::Integer</code> specifies the number of parameters in the formula. If it is positive, the formula takes exactly <code>params</code> parameters; if it is negative, the formula takes at most <code>-param</code> parameters. This allows one to define formulas using functions with an unspecified number of parameters, as e.g. polynomials of various orders (see <a href="index.html#POLY"><code>POLY</code></a> and <a href="index.html#piecewisefitsection"><code>piecewisefit</code></a>). The argument <code>value::Function</code> is a function with interface <code>value(x::Real, a::Vector{Any})</code> that returns a value given <code>x</code> and the array of parameters <code>a</code>. If <code>value</code> is an anonymous function, the code defining that function is not stored in the <code>Formula</code> object and thus cannot be printed by the method <a href="index.html#Printf.format"><code>format</code></a>. For that reason, it is also possible to pass <code>value</code> as a string representing an anonymous function.</p><p>The optional argument <code>check::Function</code> is a function defined as <code>check(a, domain, included, danger, fatal)</code>. This function must return <code>true</code> if the parameters <code>a</code> can be used in the function <code>value(x, a)</code> for <code>x</code> in the domain specified by the arguments <code>domain</code> and <code>included</code> (see <a href="index.html#piecesection"><code>Piece</code></a>), and <code>false</code> otherwise. The arguments <code>danger::Bool</code> and <code>fatal::Bool</code> should be used to switch on and off warning and error messages, respectively (see <strong>Example</strong> in <a href="index.html#Piecewise.Formula"><code>Formula</code></a>). By default, <code>check = (a, domain, included, danger, fatal) -&gt; true</code>, which means that no check is performed.</p><p>The optional argument <code>scale::Function</code> is a function with interface <code>scale(a::Vector{Any}, s::Number)</code> that returns the parameters of the formula after multiplication by the scalar <code>s</code>. By default, <code>scale = (a, s) -&gt; [a[1:end-1]..., a[end] * s]</code>, which means that only the last parameter is scaled. The optional argument <code>mirror::Function</code> is a function with interface <code>mirror(a::Vector{Any})</code> that returns the parameters of the formula after even reflection through <span>$x=0$</span>. By default, <code>mirror = a -&gt; [-a[1], a[2:end]...]</code>, which means that the first parameter is negated and the others are unchanged.</p><div class="admonition is-warning" id="Warning-2ca9dace094558ee"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-2ca9dace094558ee" title="Permalink"></a></header><div class="admonition-body"><p>If the arguments <code>value</code>, <code>check</code>, <code>scale</code>, and <code>mirror</code> are function names (rather than anonymous functions), the function name is stored in the structure <a href="index.html#Piecewise.Formula"><code>Formula</code></a>, not the function definition. If the function is redefined after the <a href="index.html#Piecewise.Formula"><code>Formula</code></a> object has been created, that object will use the new function.</p></div></div><h2 id="Domains-and-boundaries"><a class="docs-heading-anchor" href="#Domains-and-boundaries">Domains and boundaries</a><a id="Domains-and-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Domains-and-boundaries" title="Permalink"></a></h2><p>The following rules determine which value is returned by the method <code>PiecewiseFunction(x)</code>.</p><ul><li>The value <code>0</code> is returned if <code>x</code> does not belong to any of the domains defined in <code>PiecewiseFunction.pieces</code>, with two exceptions:<ol><li>The value <code>Inf</code> is returned if <code>x</code> coincides with the common boundary of two domains (this boundary being excluded from both domains) and if the rules for <code>x-ϵ</code> and <code>x+ϵ</code> both yield positive values, where <code>ϵ = 10 *  eps(Float64)</code> <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</li><li>The value <code>-Inf</code> is returned in the same situation if the rules for <code>x-ϵ</code> and <code>x+ϵ</code> both yield negative values <sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup>.</li></ol></li><li>If <code>x</code> coincides with the common boundary of two domains and if this boundary is included in both domains, the rule of the leftmost domain is used.</li><li>If <code>x</code> falls inside the domain of a piece, the rule of that piece is used.</li></ul><h2 id="Main-methods"><a class="docs-heading-anchor" href="#Main-methods">Main methods</a><a id="Main-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Main-methods" title="Permalink"></a></h2><h5 id="integraltransform"><a class="docs-heading-anchor" href="#integraltransform"><code>integraltransform</code></a><a id="integraltransform-1"></a><a class="docs-heading-anchor-permalink" href="#integraltransform" title="Permalink"></a></h5><p>A function returning the integral transform of the piecewise function <code>f</code> may be created as:</p><pre><code class="nohighlight hljs">Kof(X) = integraltransform(f::PiecewiseFunction, X::Any)</code></pre><p>This assumes that for each <a href="index.html#Piecewise.Formula"><code>Formula</code></a> object <code>F</code> used in the pieces of <code>f</code>, there is a method <code>F.value(x::Real, a::Vector{Any}, X::Any)</code> returning the primitive of <code>F.value(x, a) * K(x, X)</code> for the kernel <code>K</code> of interest (see <a href="index.html#Fast-integral-transforms">Fast integral transforms</a>). If the function <code>f</code> is <code>:even</code> or <code>:odd</code>, the method <a href="index.html#integraltransform"><code>integraltransform</code></a> requires instead a method <code>F.value(s, x::Real, a::Vector{Any}, X::Any)</code> with <code>s = 1</code> or <code>s = -1</code>, respectively, which returns the primitive of <code>F.value(x, a) * (K(x, X) + s * K(-x, X))</code>.</p><h5 id="moment"><a class="docs-heading-anchor" href="#moment"><code>moment</code></a><a id="moment-1"></a><a class="docs-heading-anchor-permalink" href="#moment" title="Permalink"></a></h5><p>The moment of order <span>$n$</span> of the piecewise function <code>f</code> may be obtained as</p><pre><code class="nohighlight hljs">m = moment(f::PiecewiseFunction, n::Integer)</code></pre><p>This assumes that for each <a href="index.html#Piecewise.Formula"><code>Formula</code></a> object <code>F</code> used in the pieces of <code>f</code>, there is a method <code>F.value(x::Real, a::Vector{Any}, n::Integer)</code> returning the primitive of <code>F.value(x, a) * x^n</code>. The argument <code>n</code> must be a non-negative integer.</p><h5 id="piecewisefitsection"><a class="docs-heading-anchor" href="#piecewisefitsection"><code>piecewisefit</code></a><a id="piecewisefitsection-1"></a><a class="docs-heading-anchor-permalink" href="#piecewisefitsection" title="Permalink"></a></h5><p>Given a function <span>$g(x)$</span>, a <a href="index.html#PiecewiseFunction"><code>PiecewiseFunction</code></a> object approximating this function can be constructed as:</p><pre><code class="nohighlight hljs">f = piecewisefit(g, domain, formulas; kwargs...)</code></pre><p>The argument <code>g(::Real)</code> is the function to approximate. The algorithm tries to fit any linear superposition of the formulas given in the argument <code>formulas::Vector{Formula}</code> to <span>$g(x)$</span> in the domain specified by the argument <code>domain::Tuple{Real, Real}</code>. The fit is successful if it matches the function within a specified tolerance and if the fitted parameters pass the tests implemented in the method <code>F.check</code> of each <a href="index.html#Piecewise.Formula"><code>Formula</code></a> object used. If the fit is unsuccessful, the domain is divided in two and the algorithm continues recursively in each sub-domain. The recursion uses the available threads, although the parallelism isn&#39;t optimal yet.</p><p>The argument <code>formulas</code> can hold several <a href="index.html#Piecewise.Formula"><code>Formula</code></a> objects with fixed number of parameters and at most one <a href="index.html#Piecewise.Formula"><code>Formula</code></a> object with a variable number of parameters. The formulas with fixed number of parameters are tried first, then the one with variable number of parameters, if any, progressively increasing the number of parameters up to the maximum number allowed. Then pairwise linear combinations are tried, and so on until one combination succeeds.</p><p>If the function <span>$g(x)$</span> is noiseless, the algorithm should converge with relatively large sub-domains. If <span>$g(x)$</span> has numerical noise, the algorithm will likely be trapped trying to piecewise-fit that noise. To avoid this, a minimal sub-domain size may be specified with the optional argument <code>grain</code>. If <code>grain &gt; eps(Float64)</code>, the algorithm returns the best possible fit in sub-domains of typical size <code>grain</code>. If no fit is successful, or if <code>grain = eps(Float64)</code>, the algorithm returns a <a href="index.html#Piecewise.Piece"><code>Piece</code></a> object that uses either the function <span>$g(x)$</span> if the optional argument <code>loop</code> is <code>true</code>, or a linear interpolation of <span>$g(x)$</span> across the domain if it is <code>false</code> (default). On the other hand, relevant rapid variations of <span>$g(x)$</span> may be missed by the algorithm, because it tries to minimize the number of calls to <code>g(x)</code>. The optional argument <code>resolution</code> allows one to control how finely the function <span>$g(x)$</span> is sampled.</p><p>Because <a href="index.html#Piecewise.piecewisefit"><code>piecewisefit</code></a> operates independently in each piece, the fitted function <span>$f(x)$</span> may display small discontinuities at the boundaries of the domains, despite <span>$g(x)$</span> being continuous there. To try and enforce approximate continuity, sampling points are introduced at the boundaries to better constrain the fitting.</p><p>The optional keyword arguments are:</p><ul><li><p><code>parity::Symbol</code>: imposes a given parity (<code>:even</code> or <code>:odd</code>) to the <a href="index.html#PiecewiseFunction"><code>PiecewiseFunction</code></a> object (by default <code>parity = :none</code>)</p></li><li><p><code>singularities::Vector{Real}</code>: values of <span>$x$</span> that are treated as singularities, i.e., excluded from any sub-domain generated during the recursion (by default <code>singularities = []</code>)</p></li><li><p><code>cuts::Vector{Real}</code>: values of <span>$x$</span> that are forced to be piece boundaries (by default <code>cuts = []</code>)</p></li><li><p><code>grain::Real</code>: sub-domains of size smaller than <code>grain</code> are not split further by the algorithm (by default <code>grain = eps(Float64)</code>)</p></li><li><p><code>resolution::Real</code>: no fit is accepted before sampling the function <span>$g(x)$</span> in each sub-domain with at most a distance <code>resolution</code> between successive points (by default <code>resolution = Inf</code>)</p></li><li><p><code>rtol::Real</code>, <code>atol::Real</code>: a fit is successful if <code>abs(dg) &lt; rtol * abs(g) + atol</code>, where <code>dg</code> are the residuals and <code>g</code> are the function values (by default <code>rtol = 0</code>, <code>atol=eps(Float64)</code>)</p></li><li><p><code>loop::Bool</code>: if <code>true</code>, the returned <a href="index.html#PiecewiseFunction"><code>PiecewiseFunction</code></a> object uses the function <span>$g(x)$</span> in sub-domains where the fit fails, otherwise it uses a linear interpolation of <span>$g(x)$</span> across the sub-domain (by default <code>loop = false</code>).</p></li></ul><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>The following example adds <a href="index.html#PiecewiseFunction"><code>PiecewiseFunction</code></a> objects to display the <a href="https://en.wikipedia.org/wiki/Cantor_set">Cantor set</a>.</p><pre><code class="language-julia hljs"># Rule to construct the set
cut(d) = [(d[1], d[1] + 1//3 * (d[2] - d[1])),
    (d[1] + 2//3 * (d[2] - d[1]), d[2])]
set(n) = n == 0 ? [(0, 1)] : vcat(cut.(set(n - 1))...)

# Piecewise function at order n
cantor(n) = PiecewiseFunction([Piece(d, x -&gt; exp(-n / 3)) for d in set(n)])

# Plot sum of piecewise functions
using Plots
# Define array x with all breakpoints
x = vcat(map(b -&gt; [b - eps(Float64), b + eps(Float64)],
    vcat(map(d -&gt; [d[1], d[2]], set(6))...))...)
plot(x, sum([cantor(n) for n = 0:6]).(x),
    f=(0, 0, :black), linewidth=0, axis=false, grid=false, legend=:none)</code></pre><p><img src="cantor.svg" alt/></p><h2 id="Formulas"><a class="docs-heading-anchor" href="#Formulas">Formulas</a><a id="Formulas-1"></a><a class="docs-heading-anchor-permalink" href="#Formulas" title="Permalink"></a></h2><p>The module <a href="https://github.com/ChristopheBerthod/Piecewise.jl">Piecewise</a> provides several <a href="index.html#Piecewise.Formula"><code>Formula</code></a> objects with appropriate primitives for computing the moments of a piecewise function. In the descriptions below, <span>$x_{\min}$</span> and <span>$x_{\max}$</span> refer to the boundaries of the domain in which the formula is used and <span>${_2F_1}(a,b,c,z)$</span> refers to the <a href="https://en.wikipedia.org/wiki/Hypergeometric_function">hypergeometric function</a>. This function has a branch cut on the real axis <span>$z=x\in\mathbb{R}$</span> for <span>$x&gt;1$</span>. In all cases considered here, <span>${_2F_1}(a,b,c,x)$</span> refers to the value below the cut, i.e., <span>${_2F_1}(a,b,c,x-i0)$</span>.</p><p><a href="index.html#POLY"><code>POLY</code></a> |  <a href="index.html#TAIL"><code>TAIL</code></a> |  <a href="index.html#LOG"><code>LOG</code></a> | <a href="index.html#ISRS"><code>ISRS</code></a> | <a href="index.html#PLS"><code>PLS</code></a> | <a href="index.html#XLOG"><code>XLOG</code></a> | <a href="index.html#XISRS"><code>XISRS</code></a></p><hr/><h5 id="POLY"><a class="docs-heading-anchor" href="#POLY"><code>POLY</code></a><a id="POLY-1"></a><a class="docs-heading-anchor-permalink" href="#POLY" title="Permalink"></a></h5><ul><li><em>Polynomial of varying order</em></li><li><em>1 to 13 parameters</em></li></ul><p>The function <code>POLY.value(x, a)</code> is</p><p class="math-container">\[F(x,\mathbf{a}) = \sum_{i=1}^k a_i x^{i-1},\]</p><p>where the number of parameters can vary in the range <span>$1\leqslant k\leqslant 13$</span>. The order of the polynomial is limited to 12 in order to reduce numerical instabilities. The parameters <span>$a_i$</span> are unrestricted.</p><p>The primitive function for the moment of order <span>$n$</span> is</p><p class="math-container">\[\mathcal{F}(x,\mathbf{a},n) = \sum_{i=1}^k \frac{a_i}{i+n} x^{i+n}.\]</p><p>This primitive is continuous for <span>$x\in\mathbb{R}$</span>.</p><hr/><h5 id="TAIL"><a class="docs-heading-anchor" href="#TAIL"><code>TAIL</code></a><a id="TAIL-1"></a><a class="docs-heading-anchor-permalink" href="#TAIL" title="Permalink"></a></h5><ul><li><em>Rational function approaching zero as <span>$1/x$</span> or <span>$1/x^2$</span> at infinity</em></li><li><em>5 parameters</em></li></ul><p>The function <code>TAIL.value(x, a)</code> is</p><p class="math-container">\[F(x,\mathbf{a}) = \frac{a_1+a_2x}{a_3+a_4x+a_5x^2}.\]</p><p>The parameters must satisfy either <span>$a_4^2-4a_3a_5 &lt; 0$</span>, such that the zeros of the denominator are not on the real axis, or they must ensure that the two zeros <span>$x_{\pm}=\frac{1}{2a_5}\left(-a_4\pm\sqrt{a_4^2-4a_3a_5}\right)$</span> lie outside the domain.</p><p>The primitive function for the moment of order <span>$n$</span> is</p><p class="math-container">\[\begin{align*}
\mathcal{F}(x,\mathbf{a},n) &amp;= \frac{x^{n+1}}{2(n+1)a_3\Delta}\left\{
\left[2a_2a_3-a_1\left(a_4-\Delta\right)\right]
{_2F_1}\left(1,n+1,n+2,\frac{-2a_5x}{a_4+\Delta}\right)\right.\\
&amp;\quad\left.-\left[2a_2a_3-a_1\left(a_4+\Delta\right)\right]
{_2F_1}\left(1,n+1,n+2,\frac{-2a_5x}{a_4-\Delta}\right)\right\}.
\end{align*}\]</p><p>where <span>$\Delta=\sqrt{a_4^2-4a_3a_5}$</span>. Simpler expressions are used if, e.g., <span>$a_3=0$</span>. This primitive is continuous for <span>$x\in\mathbb{R}$</span>, except at the zeros <span>$x=x_{\pm}$</span>, if they are on the real axis.</p><hr/><h5 id="LOG"><a class="docs-heading-anchor" href="#LOG"><code>LOG</code></a><a id="LOG-1"></a><a class="docs-heading-anchor-permalink" href="#LOG" title="Permalink"></a></h5><ul><li><em>Logarithmic singularity</em></li><li><em>2 parameters</em></li></ul><p>The function <code>LOG.value(x, a)</code> is</p><p class="math-container">\[F(x,\mathbf{a}) = a_2\ln|x-a_1|.\]</p><p>The domain should not include the point <span>$x=a_1$</span>.</p><p>The primitive function for the moment of order <span>$n$</span> is</p><p class="math-container">\[\mathcal{F}(x,\mathbf{a},n) = \frac{a_2x^{n+1}}{(n+1)(n+2)a_1}\left[
(n+2)a_1\ln|x-a_1|+{_2F_1}\left(1,n+2,n+3,\frac{x}{a_1}\right)x\right].\]</p><p>A simpler expression is used if <span>$a_1=0$</span>. This primitive is continuous in any domain excluding <span>$x=a_1$</span>.</p><hr/><h5 id="ISRS"><a class="docs-heading-anchor" href="#ISRS"><code>ISRS</code></a><a id="ISRS-1"></a><a class="docs-heading-anchor-permalink" href="#ISRS" title="Permalink"></a></h5><ul><li><em>Inverse square-root singularity</em></li><li><em>2 parameters</em></li></ul><p>The function <code>ISRS.value(x, a)</code> is</p><p class="math-container">\[F(x,\mathbf{a}) = \frac{a_2}{\sqrt{|x^2-a_1^2|}}.\]</p><p>The domain should not include any of the points <span>$x=\pm a_1$</span>.</p><p>The primitive function for the moment of order <span>$n$</span> is</p><p class="math-container">\[\mathcal{F}(x,\mathbf{a},n) = \frac{a_2x^{n+1}}{(n+1)\sqrt{|x^2-a_1^2|}}
\sqrt{1-\left(\frac{x}{a_1}\right)^2}{_2F_1}\left(\frac{1}{2},\frac{n+1}{2},
\frac{n+3}{2},\left(\frac{x}{a_1}\right)^2\right).\]</p><p>A simpler expression is used if <span>$a_1=0$</span>. This primitive is continuous in any domain excluding <span>$x=\pm a_1$</span>.</p><hr/><h5 id="PLS"><a class="docs-heading-anchor" href="#PLS"><code>PLS</code></a><a id="PLS-1"></a><a class="docs-heading-anchor-permalink" href="#PLS" title="Permalink"></a></h5><ul><li><em>Power-law singularity</em></li><li><em>3 parameters</em></li></ul><p>The function <code>PLS.value(x, a)</code> is</p><p class="math-container">\[F(x,\mathbf{a}) = a_3|x-a_1|^{a_2}.\]</p><p>The parameter <span>$a_1$</span> must be outside the domain, i.e. <span>$a_1\leqslant x_{\min}$</span> or <span>$a_1\geqslant x_{\max}$</span>, with the equal sign allowed only if <span>$a_2\geqslant0$</span>. The exponent <span>$a_2$</span> must be in the range <span>$[-12, 12]$</span> (to reduce numerical instabilities like in <a href="index.html#POLY"><code>POLY</code></a>).</p><p>The primitive function for the moment of order <span>$n$</span> is</p><p class="math-container">\[\mathcal{F}(x,\mathbf{a},n) = \frac{a_3|x-a_1|^{a_2}x^{n+1}}{n+1}
\left(1-\frac{x}{a_1}\right)^{-a_2}
{_2F_1}\left(n+1,-a_2,n+2,\frac{x}{a_1}\right).\]</p><p>A simpler expression is used if <span>$a_1=0$</span>. This primitive is continuous in any domain excluding <span>$x=a_1$</span>.</p><hr/><h5 id="XLOG"><a class="docs-heading-anchor" href="#XLOG"><code>XLOG</code></a><a id="XLOG-1"></a><a class="docs-heading-anchor-permalink" href="#XLOG" title="Permalink"></a></h5><ul><li><em>Logarithmic singularity times <span>$x$</span></em></li><li><em>2 parameters</em></li></ul><p>The function <code>XLOG.value(x, a)</code> is</p><p class="math-container">\[F(x,\mathbf{a}) = a_2x\ln|x-a_1|.\]</p><p>The domain should not include the point <span>$x=a_1$</span>.</p><p>The primitive function for the moment of order <span>$n$</span> is</p><p class="math-container">\[\mathcal{F}(x,\mathbf{a},n) = \frac{a_2x^{n+2}}{(n+2)(n+3)a_1}\left[
(n+3)a_1\ln|x-a_1|+{_2F_1}\left(1,n+3,n+4,\frac{x}{a_1}\right)x\right].\]</p><p>A simpler expression is used if <span>$a_1=0$</span>. This primitive is continuous in any domain excluding <span>$x=a_1$</span>.</p><hr/><h5 id="XISRS"><a class="docs-heading-anchor" href="#XISRS"><code>XISRS</code></a><a id="XISRS-1"></a><a class="docs-heading-anchor-permalink" href="#XISRS" title="Permalink"></a></h5><ul><li><em>Inverse square-root singularity times <span>$x$</span></em></li><li><em>2 parameters</em></li></ul><p>The function <code>XISRS.value(x, a)</code> is</p><p class="math-container">\[F(x,\mathbf{a}) = \frac{a_2x}{\sqrt{|x^2-a_1^2|}}.\]</p><p>The domain should not include any of the points <span>$x=\pm a_1$</span>.</p><p>The primitive function for the moment of order <span>$n$</span> is</p><p class="math-container">\[\mathcal{F}(x,\mathbf{a},n) = \frac{a_2x^{n+2}}{(n+2)\sqrt{|x^2-a_1^2|}}
\sqrt{1-\left(\frac{x}{a_1}\right)^2}{_2F_1}\left(\frac{1}{2},\frac{n}{2}+1,
\frac{n}{2}+2,\left(\frac{x}{a_1}\right)^2\right).\]</p><p>A simpler expression is used if <span>$a_1=0$</span>. This primitive is continuous in any domain excluding <span>$x=\pm a_1$</span>.</p><h2 id="Public-interface"><a class="docs-heading-anchor" href="#Public-interface">Public interface</a><a id="Public-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Public-interface" title="Permalink"></a></h2><h3 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h3><ul><li><a href="index.html#Piecewise.Formula"><code>Piecewise.Formula</code></a></li><li><a href="index.html#Piecewise.Piece"><code>Piecewise.Piece</code></a></li><li><a href="index.html#Piecewise.PiecewiseFunction"><code>Piecewise.PiecewiseFunction</code></a></li><li><a href="index.html#Piecewise.ISRS"><code>Piecewise.ISRS</code></a></li><li><a href="index.html#Piecewise.LOG"><code>Piecewise.LOG</code></a></li><li><a href="index.html#Piecewise.PLS"><code>Piecewise.PLS</code></a></li><li><a href="index.html#Piecewise.POLY"><code>Piecewise.POLY</code></a></li><li><a href="index.html#Piecewise.TAIL"><code>Piecewise.TAIL</code></a></li><li><a href="index.html#Piecewise.XISRS"><code>Piecewise.XISRS</code></a></li><li><a href="index.html#Piecewise.XLOG"><code>Piecewise.XLOG</code></a></li><li><a href="index.html#Piecewise.domains"><code>Piecewise.domains</code></a></li><li><a href="index.html#Piecewise.formulas"><code>Piecewise.formulas</code></a></li><li><a href="index.html#Piecewise.integraltransform"><code>Piecewise.integraltransform</code></a></li><li><a href="index.html#Piecewise.intervals"><code>Piecewise.intervals</code></a></li><li><a href="index.html#Piecewise.moment"><code>Piecewise.moment</code></a></li><li><a href="index.html#Piecewise.piecewisefit"><code>Piecewise.piecewisefit</code></a></li><li><a href="index.html#Piecewise.singularities"><code>Piecewise.singularities</code></a></li><li><a href="index.html#Piecewise.support"><code>Piecewise.support</code></a></li></ul><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.Formula" href="#Piecewise.Formula"><code>Piecewise.Formula</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Formula([name::String,] params::Integer, value::Function
    [, check::Function][, scale::Function][, mirror::Function])</code></pre><p>Return a <code>Formula</code> object with an optional name.</p><p>The <code>Formula</code> takes exactly <code>params</code> parameters if <code>params &gt;= 0</code> and at most <code>-params</code> parameters if <code>params &lt; 0</code>. The value of the formula is set by the function <code>value(::Real, ::Vector{Any})</code>. The optional function <code>check(a::Vector{Any}, domain::Tuple{Real, Real}, included::Tuple{Bool, Bool}, danger::Bool, fatal::Bool)</code> must return <code>true</code> or <code>false</code>, depending on whether the function <code>value(x, a)</code> is valid in the domain specified by <code>domain</code> and <code>included</code> (see <a href="index.html#Piecewise.Piece"><code>Piece</code></a>) with the parameters <code>a</code>. Warnings must be issued by <code>check</code> only if <code>danger</code> is <code>true</code> and errors must be thrown only if <code>fatal</code> is <code>true</code>. The optional function <code>scale(a::Vector{Any}, s::Number)</code> must return the parameters after multiplication of the formula by <code>s</code>, by default <code>scale = (a, s) -&gt; [a[1:end-1]..., a[end] * s]</code>. The optional function <code>mirror(a::Vector{Any})</code> must return the parameters after even reflection of the formula through <span>$x=0$</span>, by default mirror = <code>a -&gt; [-a[1], a[2:end]...]</code>.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code></li><li><code>params::Integer</code></li><li><code>value::Function</code></li><li><code>check::Function</code></li><li><code>scale::Function</code></li><li><code>mirror::Function</code></li></ul><p><strong>Example</strong></p><p>This creates a square-root singularity:</p><pre><code class="language-julia-repl hljs">julia&gt; srs(x, a) = a[2] * sqrt(x - a[1]);

julia&gt; function srs(a, domain, included, danger, fatal)
           t = domain[1] &gt; a[1] || (domain[1] == a[1] &amp;&amp; ! included[1])
           !t &amp;&amp; fatal &amp;&amp; throw(ArgumentError(&quot;Singularity must be at left of domain.&quot;))
           t || return false
           t = a[2] &gt;= 0
           !t &amp;&amp; danger &amp;&amp; @warn &quot;Negative singularity in domain $(domain).&quot;
           return true
       end;

julia&gt; F = Formula(&quot;SRS&quot;, 2, srs, srs)
Formula(&quot;SRS&quot;, 2, srs, srs)

julia&gt; F.check([1, 1], (0, 2), (true, true), true, false)
false

julia&gt; F.check([-1, -1], (0, 2), (true, true), true, false)
┌ Warning: Negative singularity in domain (0, 2).
└ @ Main REPL[3]:6
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/types.jl#L3-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.Piece" href="#Piecewise.Piece"><code>Piecewise.Piece</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Piece(domain[, included=(true, true)], rule, parameters)</code></pre><p>Return a <code>Piece</code> object in the domain <code>domain::Tuple{Real, Real}</code>.</p><p>The argument <code>included</code> tells whether the domain boundaries belong to the domain. The arguments <code>rule::Vector{Formula}</code> and <code>parameters::Vector{Vector{Any}}</code> specify the rule used to evaluate the value of the piece (see <a href="index.html#Piecewise.Formula"><code>Formula</code></a>). For a single formula, it is also possible to pass <code>rule::Formula</code> and <code>parameters::Vector{Any}</code>.</p><pre><code class="nohighlight hljs">Piece(domain[, included=(true, true)], function)</code></pre><p>Initialization with a single function. This is equivalent to <code>Piece(domain[, included], Formula(0, (x, a) -&gt; function(x)), Any[])</code>.</p><p><strong>Fields</strong></p><ul><li><code>domain::Tuple{Real, Real}</code></li><li><code>included::Tuple{Bool, Bool}</code></li><li><code>rule::Vector{Formula}</code></li><li><code>parameters::Vector{Vector{Any}}</code></li></ul><p><strong>Examples</strong></p><p>This represents <span>$1/x$</span> for strictly positive numbers:</p><pre><code class="language-julia-repl hljs">julia&gt; Piece((0, Inf), (false, true), x -&gt; 1 / x)
&lt; Piece of type unnamed in the domain ]0.0, Inf] &gt;
</code></pre><p>This represents <span>$-\log|x|$</span> for <span>$x\in ]0, 1]$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; Piece((0, 1), (false, true), Formula(&quot;LOG&quot;, 1, (x, a) -&gt; a[1] * log(abs(x))), [-1])
&lt; Piece of type LOG in the domain ]0.0, 1.0] &gt;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/types.jl#L208-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.PiecewiseFunction" href="#Piecewise.PiecewiseFunction"><code>Piecewise.PiecewiseFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PiecewiseFunction([parity=:none,] pieces::Vector{Piece})</code></pre><p>Return a <code>PiecewiseFunction</code> object.</p><p>The optional argument <code>parity</code> can be <code>:none</code>, <code>:even</code>, or <code>:odd</code>. The argument <code>pieces</code> contains the various pieces (see <a href="index.html#Piecewise.Piece"><code>Piece</code></a>). It is also possible to pass a single piece as <code>pieces::Piece</code>.</p><p><strong>Fields</strong></p><ul><li><code>parity::Symbol</code></li><li><code>pieces::Vector{Piece}</code></li></ul><p><strong>Example</strong></p><p>This represents the Cauchy principal value of <span>$1/x$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; f = PiecewiseFunction(:odd, Piece((0, Inf), (false, true), x -&gt; 1 / x))
&lt; Piecewise odd function with 1 piece and support [-Inf, Inf] &gt;

julia&gt; f.([-1, 0, 1])
3-element Vector{Real}:
 -1.0
  0
  1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/types.jl#L317-L345">source</a></section></article><h3 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.POLY" href="#Piecewise.POLY"><code>Piecewise.POLY</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Polynomial of varying order (1 to 13 parameters)</p><p class="math-container">\[F(x,\mathbf{a}) = \sum_{i=1}^n a_i x^{i-1}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.TAIL" href="#Piecewise.TAIL"><code>Piecewise.TAIL</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Rational function approaching zero as <span>$1/x$</span> or <span>$1/x^2$</span> at infinity (5 parameters)</p><p class="math-container">\[F(x,\mathbf{a}) = \frac{a_1+a_2x}{a_3+a_4x+a_5x^2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.LOG" href="#Piecewise.LOG"><code>Piecewise.LOG</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Logarithmic singularity (2 parameters)</p><p class="math-container">\[F(x,\mathbf{a}) = a_2\ln|x-a_1|\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L205-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.ISRS" href="#Piecewise.ISRS"><code>Piecewise.ISRS</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Inverse square-root singularity (2 parameters)</p><p class="math-container">\[F(x,\mathbf{a}) = \frac{a_2}{\sqrt{|x^2-a_1^2|}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.PLS" href="#Piecewise.PLS"><code>Piecewise.PLS</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Power-law singularity (3 parameters)</p><p class="math-container">\[F(x,\mathbf{a}) = a_3|x-a_1|^{a_2}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L223-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.XLOG" href="#Piecewise.XLOG"><code>Piecewise.XLOG</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Logarithmic singularity times <span>$x$</span> (2 parameters)</p><p class="math-container">\[F(x,\mathbf{a}) = a_2x\ln|x-a_1|\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.XISRS" href="#Piecewise.XISRS"><code>Piecewise.XISRS</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Inverse square-root singularity times <span>$x$</span> (2 parameters)</p><p class="math-container">\[F(x,\mathbf{a}) = \frac{a_2x}{\sqrt{|x^2-a_1^2|}}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L241-L246">source</a></section></article><h3 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.domains" href="#Piecewise.domains"><code>Piecewise.domains</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">domains(f::PiecewiseFunction)</code></pre><p>Return the domains of the piecewise function <code>f</code> as a <code>Vector{Tuple{Real, Real}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.intervals" href="#Piecewise.intervals"><code>Piecewise.intervals</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">intervals(f::PiecewiseFunction)</code></pre><p>Return a <code>Vector{String}</code> representing the domains and boundaries of the piecewise function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.support" href="#Piecewise.support"><code>Piecewise.support</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">support(f::PiecewiseFunction)</code></pre><p>Return the support of the piecewise function <code>f</code> as a <code>Tuple{Real, Real}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.singularities" href="#Piecewise.singularities"><code>Piecewise.singularities</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">singularities(f::PiecewiseFunction)</code></pre><p>Return the singularities of the piecewise function <code>f</code> as a <code>Vector{Real}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.formulas" href="#Piecewise.formulas"><code>Piecewise.formulas</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">formulas(f::PiecewiseFunction)</code></pre><p>Return the formula names used in the piecewise function <code>f</code> as a <code>Vector{String}</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.integraltransform" href="#Piecewise.integraltransform"><code>Piecewise.integraltransform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">integraltransform(f::PiecewiseFunction, X::Any)</code></pre><p>Return the integral transform of the piecewise function <code>f</code>, defined as</p><p class="math-container">\[(K\circ f)(\mathbf{X}) = \int_{-\infty}^{\infty}dx\,f(x)K(x,\mathbf{X}).\]</p><p>This method assumes that each function <code>F(::Real, ::Vector{Any})</code> used in the piecewise function <code>f</code> has a method <code>F(::Real, ::Vector{Any}, ::Any)</code> that returns the primitive of <span>$F(x, \mathbf{a})$</span> multiplied by the kernel <span>$K(x, \mathbf{X})$</span>, i.e., <code>d/dx F(x, a, X) = F(x, a) * K(x, X)</code>. If <code>f.parity</code> is <code>:even</code> or <code>:odd</code>, <code>integraltransform</code> requires a method <code>F(::Integer, ::Real, ::Vector{Any}, ::Any)</code> such that <code>d/dx F(1, x, a, X) = F(x, a) * (K(x, X) + K(-x, X))</code> and <code>d/dx F(-1, x, a, X) = F(x, a) * (K(x, X) - K(-x, X))</code>.</p><p><strong>Example</strong></p><p>This define a <code>Formula</code> object <code>LIN</code> that can be used to represent any piecewise linear function, and such that <code>integraltransform</code> provides its Fourier transform:</p><pre><code class="language-jldocs hljs">julia&gt; F(x, a) = a[1] + a[2] * x;

julia&gt; LIN = Formula(&quot;LIN&quot;, 2, F, (a, s) -&gt; a * s, a -&gt; [a[1], -a[2]]);

julia&gt; F(x, a, k) = (a[1] * k + a[2] * (k * x + im)) * exp(im * k * x)/(im * k^2);

julia&gt; F(s, x, a, k) = 2 * (s == 1 ? real(F(x, a, k)) : im * imag(F(x, a, k)));

julia&gt; f = PiecewiseFunction(:even, [Piece((0, π), LIN, [π, -1])])
&lt; Piecewise even function with 1 piece and support [-3.1416, 3.1416] &gt;

julia&gt; integraltransform(f, 1)
4.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L250-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.moment" href="#Piecewise.moment"><code>Piecewise.moment</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">moment(f::PiecewiseFunction, n::Integer)</code></pre><p>Return the moment of order <code>n</code> of the piecewise function <code>f</code>, defined as</p><p class="math-container">\[(M\circ f)(n) = \int_{-\infty}^{\infty}dx\,f(x)x^n.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L289-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Piecewise.piecewisefit" href="#Piecewise.piecewisefit"><code>Piecewise.piecewisefit</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">piecewisefit(f::Function, domain::Tuple{Real, Real}, formulas::Vector{Formula}; kwargs...)</code></pre><p>Return a piecewise approximation of the real-valued function <code>f(::Real)</code> in the domain <code>domain</code>, using the formulas given in the array <code>formulas</code> (see <a href="index.html#Piecewise.Formula"><code>Formula</code></a>).</p><p><strong>Optional keyword arguments</strong></p><ul><li><code>parity</code> : Impose a parity (<code>:even</code> or <code>:odd</code>, default <code>:none</code>) to  the piecewise function</li><li><code>singularities</code> : Points excluded from the domains (default <code>Real[]</code>)</li><li><code>cuts</code> : Points forced to be piece boundaries (default <code>Real[]</code>)</li><li><code>grain</code> : Minimal domain size, default <code>eps(Float64)</code></li><li><code>resolution</code> : Maximal distance between sampled points, default <code>Inf</code></li><li><code>rtol</code> : Relative tolerance, default <code>0.0</code></li><li><code>atol</code> : Absolute tolerance, default <code>eps(Float64)</code></li><li><code>loop</code> : Whether to return <code>f</code> in case of failure in a domain, default <code>false</code></li></ul><p><strong>Example</strong></p><p>Here is a one-piece approximation to the function <span>$\sin^{-1}(x)$</span>. The power law at <span>$x=1$</span> is represented exactly and a polynomial is fit to the rest:</p><pre><code class="language-jldocs hljs">julia&gt; f = PiecewiseFunction(:odd, Piece((0, 1), PLS, [1, 1 / 2, -sqrt(2)])) +
           piecewisefit(x -&gt; asin(x) + sqrt(2 - 2 * x), (0, 1), [POLY],
           parity=:odd, atol=1e-5)
&lt; Piecewise odd function with 1 piece and support [-1.0, 1.0] &gt;

julia&gt; max([abs(f(x) - asin(x)) for x in -1:0.1:1]...) &lt; 1e-5
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L306-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Printf.format" href="#Printf.format"><code>Printf.format</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">format(f::PiecewiseFunction)</code></pre><p>Return a string holding the constructor for the <code>PiecewiseFunction</code> object <code>f</code>. For <a href="index.html#Piecewise.Formula"><code>Formula</code></a> objects than have a name, the name is used instead of the constructor of the <code>Formula</code> object. Note that <code>print(f)</code> is equivalent to <code>print(format(f))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ChristopheBerthod/Piecewise.jl/blob/36402b014088736c58bdf8ecc4980eab8fb4bc3d/Piecewise/src/public-methods.jl#L417-L423">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>The use of several formulas in a piece is therefore limited to function types for which a <code>+</code> method exists.</li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>This limits the use of <code>:odd</code> to function types for which a <code>-</code> method exists.</li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a>This limits the treatment of singularities to function types for which a <code>sign</code> method exists.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="hilbert.html">PiecewiseHilbert »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 22 September 2025 18:00">Monday 22 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
